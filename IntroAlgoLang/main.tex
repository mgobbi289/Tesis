% Tipo Documento
\documentclass{article}
% Utilizar Símbolos
\usepackage[utf8]{inputenc}
% Elegir Idioma
\usepackage[spanish]{babel}
% Enumerar en Párrafo
\usepackage[inline]{enumitem}
% Mis Comandos
\usepackage{commands}
% Configuración Código
\usepackage{lang}

\begin{document}

\title{Introducción al \Lang}
\author{Matias Gobbi}
\maketitle

\section*{Fundamentos}

Antes de comenzar propiamente con la definición formal e implementación de nuestro intérprete, lo correcto es dar una introducción al lenguaje.
Por lo tanto, en la siguiente sección nos dedicaremos a dar el significado intuitivo de las distintas construcciones que ofrece el \Lang.
Detallaremos de forma general distintos aspectos sintácticos y semánticos del mismo.

\section{Introducción}

El \Lang\space es un pseudocódigo diseñado para el desarrollo de la materia \Mat.
Por lo tanto, su uso está orientado para la enseñanza de los contenidos de la asignatura.
Los ejes principales de la materia consisten en el análisis de algoritmos, la definición de estructuras de datos y la comprensión de algoritmos avanzados.

El objetivo del pseudocódigo es poder introducir a los estudiantes a nuevos conceptos, y fomentar buenas técnicas de programación.
Se utiliza para describir de forma informal principios operacionales de los distintos algoritmos estudiados en la materia.
Típicamente, se omiten detalles esenciales para la implementación de los programas para favorecer el entendimiento de los mismos.
No existe ningún estándar para la sintaxis o semántica de \Lang, por lo que un programa en este lenguaje no es un programa ejecutable.

Este lenguaje (o más bien, pseudocódigo) está basado en el lenguaje de programación imperativo Pascal.
El mismo fue diseñado por Niklaus Wirth cerca de 1970.
Algunos elementos básicos que comparten son:
\begin{enumerate*}
\item Una sintaxis simple, verbosa pero fácil de leer.
\item Un tipado fuerte para las expresiones.
\item Un formato estructurado del código.
\end{enumerate*}

En el resto de la sección nos referiremos a \Lang\space como un lenguaje definido, a pesar de ser simplemente un pseudocódigo.
Nuestro objetivo final, es poder realizar una implementación tanto del lenguaje como de un interprete para el mismo.

\section{Características Principales}

El lenguaje está diseñado para enseñar conceptos fundamentales de forma clara y natural.
No existe ninguna implementación concreta del mismo, y tampoco hay una definición formal de ninguna de sus componentes.
Todo esto tiene ciertas consecuencias importantes.

La más inmediata es que el lenguaje es flexible en cuanto al nivel de abstracción que maneja, lo cual resulta conveniente a lo largo de la materia.
En la cátedra se suelen omitir los detalles de implementación de distintas funciones y procedimientos para poder concentrarse en los conceptos propios de algoritmos.
El lenguaje permite trabajar con estructuras como los arreglos para definir algoritmos de ordenación, o con listas enlazadas cuando se hace uso de la memoria de forma dinámica.
Pero también permite trabajar con grafos o conjuntos para los algoritmos más abstractos.
Obviamente, esto facilita la enseñanza de la materia pero posee una complicación fundamental para el desarrollo de un intérprete, la ambigüedad y falta de especificación.

Otra característica importante del lenguaje es el tipado fuerte.
Toda expresión posee un tipo, y la misma debe ser respetada.
Por ejemplo, si una variable \textit{x} es de tipo \textit{int} la misma no podrá ser usada como \textit{bool}.
Al mismo tiempo, el lenguaje ofrece varias construcciones polimórficas, y operadores sobrecargados, que funcionan para un rango de tipos distintos.
En primera instancia, no hay conversiones de tipo en el lenguaje.

Debido a que no podemos ejecutar un programa de \Lang, ya que no existe ningún intérprete ni compilador para este lenguaje, el mismo no ofrece ciertas construcciones que en la actualidad son básicas para cualquier lenguaje de programación.
A continuación enumeramos algunas:
\begin{enumerate*}
\item Canales de input y output, ya sea con archivos o mediante interacción del usuario.
\item Manejo de errores y excepciones, no hay ningún mecanismo establecido para tratar estas situaciones.
\item Creación de módulos, la división de código no resulta una necesidad para el desarrollo de la materia.
\end{enumerate*}

\section{Tokens}

Comencemos propiamente con la descripción del lenguaje.
Para la construcción del código, los bloques léxicos básicos se denomina tokens.
Se podrían definir como las palabras del lenguaje.
Los caracteres ingresados por el programador se combinan en tokens de acuerdo a las reglas del lenguaje de programación.
Hay distintas clases de tokens en \Lang:

\begin{enumerate}
\item \textbf{palabras reservadas} son las que poseen un significado fijo en el lenguaje.
No pueden ser modificadas o redefinidas.
\item \textbf{identificadores} son los nombres que el programador define para las variables, funciones, tipos, entre otras.
Pueden ser reusadas, y están sujetas a las reglas de \textit{scope}.
\item \textbf{operadores} son los símbolos para las operaciones.
Entre los mismos se encuentran los aritméticos, los booleanos, entre otros.
Se utilizan en las expresiones.
\item \textbf{separadores} comúnmente son los espacios en blanco.
También pueden ser las tabulaciones o saltos de línea.
No tienen mayor uso que mantener el código prolijo.
\item \textbf{constantes} se utilizan para denotar valores específicos en el código.
Ejemplos de estos son los valores numéricos, los booleanos, entre otros.
\end{enumerate}

A lo largo del desarrollo de esta introducción, iremos haciendo mención de cada uno de los mismos a medida que sea necesario.
En el siguiente ejemplo, ilustramos algunos de los conceptos introducidos.

\begin{lstlisting}
proc insert (in/out A: array [1..n] of T, in i: nat)
  var j: nat
  j := i
  do j > 1 $\land$ A[j] < A[j-1] $\rightarrow$
    swap(A, j - 1, j)
    j := j - 1
  od
end proc
\end{lstlisting}

Algunos ejemplos de palabras claves son \textit{proc}, \textit{in}, y \textit{var}.
Sus significados serán explicados más adelante.
Ejemplos de identificadores pueden ser \textit{A}, \textit{j}, y \textit{swap}, los cuales representan parámetros, variables y procedimientos respectivamente.
Los operadores utilizados son $>$, \sand, $<$, y $-$.
La única constante es el número \textit{1}.

Un detalle importante en el lenguaje es que \Lang\space es \textit{case sensitive}.
Esto significa que el mismo distingue entre un token en minúsculas, de uno en mayúsculas.
Debido a esto se pueden definir múltiples identificadores con el mismo nombre, pero que se diferencien por el uso de las mayúsculas o minúsculas.

\subsection{Comentarios}

Los comentarios son piezas de código que son descartados por el intérprete.
Solo existen para el beneficio del programador, para poder explicar ciertas piezas del código.
En el lenguaje solo se permiten realizar comentarios en una línea utilizando llaves, como en el siguiente ejemplo.

\begin{lstlisting}
{ Este procedimiento inicializa un arreglo }
\end{lstlisting}

\section{Tipos}

Un tipo esencialmente, define el conjunto de valores que puede tomar una variable.
En el lenguaje hay tipos básicos, tipos estructurados e incluso tipos definidos por el programador.

\subsection{Tipos Básicos}

Un tipo básico comprende un conjunto ordenable de valores.
Existe un token para cada valor del conjunto.
Poseen operaciones propias que los manipulan.
En el lenguaje existen varios tipos básicos nativos.

\subsubsection{Tipos Numéricos}

Los tipos numéricos son los siguientes: \type{nat}, \type{int} y \type{real}.
Estos representan los conjuntos de los números naturales, números enteros y números reales, respectivamente.
En el lenguaje los números se especifican en notación decimal.
A diferencia de su definición matemática, estos conjuntos están acotados.
En el lenguaje se encuentran definidas las constantes \ninf\space y \pinf, que representan los límites inferior y superior de los conjuntos de enteros y reales.
Para el conjunto de los naturales, las cotas comprenden el \textit{0} y el \pinf.

Asumiendo que \textit{n} y \textit{m} son expresiones numéricas del mismo tipo.
Los operadores aritméticos que se ofrecen son los siguientes.
Los mismos evalúan a un valor numérico.

\begin{center}
\begin{tabular}{| c | c | c |}
\hline
    Operador & Operación & Operandos\\
    \hline
    n $+$ m & Suma & Numéricos \\
    $-$ n & Resta Unaria & Enteros/Reales \\
    n $-$ m & Resta Binaria & Numéricos \\
    n $*$ m & Multiplicación & Numéricos \\
    n $/$ m & División Entera & Naturales/Enteros \\
    n $/$ m & División Exacta & Reales \\
    n $\%$ m & Módulo & Naturales/Enteros \\
    max(n, m) & Máximo & Numéricos \\
    min(n, m) & Mínimo & Numéricos \\
\hline
\end{tabular}
\end{center}

Los operadores de comparación están definidos para una gran variedad de tipos, por lo que no se limitan solo a expresiones numéricas.
De todas formas, listaremos los mismos en esta sección.
Los operadores de comparación evalúan a un valor booleano.

\begin{center}
\begin{tabular}{| c | c |}
\hline
    Operador & Operación \\
    \hline
    n $=$ m & Igualdad \\
    n $<$ m & Menor \\
    n $>$ m & Mayor \\
    n $\leq$ m & Menor o Igual \\
    n $\geq$ m & Mayor o Igual \\
    n $\neq$ m & No Igualdad \\
\hline
\end{tabular}
\end{center}

Notar que los operadores para números están sobrecargados.
Esto significa que las operaciones numéricas están definidas para naturales, enteros y reales.
Por ejemplo, la suma se puede utilizar tanto para sumar naturales entre sí, como con enteros o reales.
Lo que en el lenguaje no está especificado es si se permite utilizar operadores con operandos de distintos tipos.
Por ejemplo, si se permite sumar naturales con reales.
Esta es una decisión que se tendrá que tomar una vez que se implemente el lenguaje.

\subsubsection{Tipos Booleanos}

El tipo \type{bool} representa al conjunto de valores booleanos.
Puede adoptar los valores de verdad \textit{True} y \textit{False}.
También se ofrecen las operaciones clásicas para manejo de booleanos.
Asumiendo que \textit{b} y \textit{q} son expresiones de tipo booleano, los operadores son los siguientes.

\begin{center}
\begin{tabular}{| c | c |}
\hline
     Operador & Operación \\
     \hline
     $\neg$ b & Negación \\
     b $\lor$ q & Disyunción \\
     b $\land$ q & Conjunción \\
\hline
\end{tabular}
\end{center}

Un detalle importante en estas operaciones es el uso de la llamada evaluación por \textit{short-circuit} (correspondiente a un modo de evaluación \textit{lazy}).
La misma determina que el segundo argumento de una operación binaria será evaluado solo si el valor del primer argumento no puede determinar el valor de la expresión completa.

\subsubsection{Tipos Caracteres}

El tipo \type{char} representa al conjunto de caracteres.
Los valores que puede adoptar se representan encerrados entre comillas simples, de la forma \textit{'a'}.
Por sí solo, este tipo de dato no presenta mucha utilidad en el lenguaje y quedará relegado en un segundo plano.
Inicialmente, las únicas operaciones que se pueden realizar entre caracteres son las comparativas.

En el siguiente ejemplo se detalla una función que utiliza los tipos básicos recientemente introducidos.
La misma determina si un arreglo de caracteres posee llaves balanceadas, utilizando un contador entero.

\begin{lstlisting}
fun balanceados (A: array [1..n] of char) ret b: bool
  var count: int
  count := 0
  b := true
  for i := 1 to n do
    if A[i] = '[' then
      count := count + 1
    else if A[i] = ']' $\land$ count $\neq$ 0 then
      count := count - 1
    else if A[i] = ']' $\land$ count = 0 then
      b := false
    fi
  od
  b := b $\land$ count = 0
end fun
\end{lstlisting}

\subsubsection{Tipos Enumerados}

Los tipos enumerados representan uno de los tipos que pueden ser definidos por el programador en el lenguaje.
Para los mismos, se enumeran todos los valores posibles, entre paréntesis, que puede adoptar este tipo de dato.
Los valores serán especificados utilizando identificadores.
Las únicas operaciones disponibles para estos tipos de datos son las comparativas.

\begin{lstlisting}
type dia = (dom, lun, mar, mie, jue, vie, sab)
\end{lstlisting}

En el ejemplo anterior se define un nuevo tipo enumerado.
Se utiliza el identificador \textit{dia} para denotar al tipo.
Los valores que puede adoptar el mismo están representados por los siete identificadores entre paréntesis.

\subsection{Tipos Estructurados}

Un tipo estructurado es caracterizado por el tipo de sus componentes y por su método de estructuración.
En el lenguaje hay varios tipos estructurados.
Al igual que los tipos básicos, también hay operaciones específicas definidas para los mismos.

\subsubsection{Tipo Arreglo}

Un tipo \type{array} es una estructura que consiste de una cantidad fija de componentes del mismo tipo.
Los elementos de un arreglo son designados por índices.
Los mismos deben representar un conjunto de valores enumerables.
Para definir un arreglo se necesita especificar el tipo de los componentes y los índices de los mismos.

\begin{lstlisting}
var A: array [1..4] of int
A[1] := 1 
A[2] := 3
A[3] := 6
A[4] := 10
\end{lstlisting}

En este ejemplo, creamos un arreglo \textit{A} que estará definido para los índices \textit{1}, \textit{2}, \textit{3}, y \textit{4}, y almacenará en cada posición valores de tipo entero.
Luego, en cada posición \textit{i} del arreglo se guardará la sumatoria de los primeros \textit{i} números naturales.
Notar que el siguiente programa es equivalente al anterior, donde utilizamos el estado del arreglo para el cómputo del mismo.

\begin{lstlisting}
var A: array [1..4] of int
A[1] := 1 
A[2] := A[1] + 2
A[3] := A[2] + 3
A[4] := A[3] + 4
\end{lstlisting}

La declaración de índices de arreglos no está solamente limitada a números.
De hecho, todo los tipos que se puedan enumerar pueden ser utilizados como índices de arreglos.

\begin{lstlisting}
var B: array ['a'..'z'] of bool
var C: array [-4..12] of char
var D: array [dom..sab] of real
B['g'] := True
C[-2] := 'v'
D[vie] := 3.14
\end{lstlisting}

En el ejemplo se declaran tres arreglos distintos.
Los índices del arreglo de booleanos \textit{B} son todos los caracteres ordenados alfabéticamente desde la letra \textit{a} hasta la \textit{z}.
El arreglo de caracteres  \textit{C} tendrá índices que irán desde el número \textit{-4} hasta el \textit{12}.
Los índices del arreglo de reales \textit{D} comprenden los valores del tipo enumerado \textit{dia}.

Hay una observación importante que hay que rescatar sobre los índices de un arreglo.
Si el conjunto de índices de un arreglo es vacío, en el caso que el límite inferior sea mayor al límite superior, entonces el mismo tendrá longitud cero.
Esto sería similar a tener un tipo vacío.
Esta situación no tendría ninguna utilidad práctica.

Por último, los arreglos en \Lang\space no están limitados a una dimensión.
En particular, uno puede crear arreglos multidimensionales simplemente especificando los rangos de las dimensiones necesarias al momento de declarar un nuevo arreglo.

\begin{lstlisting}
var E: array [1..5, 1..5] of int
var F: array [1..3, 'a'..'e', 10..20] of real
E[1, 1] := 4
F[2, 'b', 15] := 4.0
\end{lstlisting}

El arreglo \textit{E} posee dos dimensiones, ambas indexadas desde el número \textit{1} al \textit{5}.
Para la asignación de valores del arreglo simplemente se separan con comas las distintas coordenadas que se quieren acceder o actualizar.
El arreglo \textit{F}, en cambio, tiene 3 dimensiones.
La primera está indexada del \textit{1} al \textit{3}, la segunda por los caracteres de la \textit{a} a la \textit{e}, y la última, va del \textit{10} al \textit{20}.

\subsubsection{Tipo Lista}

Un tipo \type{list} es una estructura compuesta por una cantidad variable de componentes del mismo tipo.
Una lista es similar a un arreglo, salvo por algunas diferencias fundamentales:
\begin{enumerate*}
\item La longitud de una lista no está predefinida.
Esto significa que el tamaño de la misma puede variar a lo largo de la ejecución de un programa.
\item Los valores de una lista no necesariamente se alojan en espacios contiguos de memoria.
Este detalle es propio de la implementación.
\end{enumerate*}
Por lo tanto, una lista se puede pensar como un arreglo dinámico.

Asumiendo que \textit{e} es una expresión del mismo tipo que los componentes de la lista \textit{l}, y que \textit{i} es una expresión de tipo natural.
Las operaciones con listas son las siguientes.

\begin{center}
\begin{tabular}{| c | l |}
\hline
     Operador & Descripción  \\
     \hline
     e $\triangleright$ l & Agrega un elemento al comienzo de la lista \\
     l $\triangleleft$ e & Agrega un elemento al final de la lista \\
     l \textbf{.} i & Devuelve el \textit{i-ésimo} elemento de la lista \\
     \#l & Devuelve la longitud de la lista \\
     head(l) & Devuelve el primer elemento de la lista \\
     tail(l) & Devuelve la lista omitiendo el primer elemento \\
     e $\in$ l & Responde si un elemento pertenece a la lista \\
     $[\ ]$ & Constante que simboliza la lista vacía \\
\hline
\end{tabular}
\end{center}

A continuación se implementan algunas funciones que utilizan las operaciones antes descriptas.
Los elementos sintácticos introducidos en estos ejemplos, junto con sus significados semánticos serán explicados en detalle en sus correspondiente secciones.

\begin{lstlisting}
fun sumatoria (L: list of nat) ret suma: nat
  suma := 0
  for l $\in$ L do
    suma := suma + l
  od
end fun
\end{lstlisting}

La función \textit{sumatoria} devuelve la sumatoria de todos los elementos de una lista.
Itera sobre cada uno de los elementos de la misma, y almacena la suma acumulada en la variable \textit{suma}.

\begin{lstlisting}
fun inicializar_lista (n: nat) ret L: list of nat
  L := [ ]
  for i := n downto 1 do
    L := i $\triangleright$ L
  od
end fun
\end{lstlisting}

La función \textit{inicializar\gbajo lista} construye una lista con los primeros \textit{n} números naturales.
Comenzando desde \textit{n}, y disminuyendo hasta \textit{1}, va agregando al comienzo de la lista cada uno de los elementos.

\begin{lstlisting}
fun existe_par (L: list of nat) ret b: bool
  b := False
  for i := 1 to # L do
    b := b $\lor$ es_par(L.i)
  od
end fun
\end{lstlisting}

La función \textit{existe\gbajo par} calcula si hay un número par en una lista determinada.
La función \textit{es\gbajo par} es una función auxiliar, que dado un natural afirma si el mismo es par o no.

\subsubsection{Tipo Conjunto}

Un tipo \type{set} es un estructura compuesta por una cantidad variable de componentes del mismo tipo.
A diferencia de las listas, en un conjunto no existe un orden entre los elementos que lo conforman.
La intuición detrás de los mismos, es igual a la de matemática.

Asumiento que \textit{P} y \textit{Q} son conjuntos del mismo tipo, y que \textit{e} es una expresión cuyo valor es del mismo tipo que los componentes de los conjuntos.
Las operaciones que se pueden realizar sobre conjuntos comprenden.

\begin{center}
\begin{tabular}{| c | l |}
\hline
     Operador & Descripción \\
     \hline
     P $\cup$ Q & Calcula la unión de conjuntos \\
     P $\cap$ Q & Calcula la intersección de conjuntos \\
     P $-$ Q & Calcula la diferencia de conjuntos \\
     $|$ P $|$ & Devuelve la cantidad de elementos del conjunto \\
     e $\in$ P & Responde si un elemento pertenece al conjunto \\
     \{ \} & Constante que simboliza el conjunto vacío \\
\hline
\end{tabular}
\end{center}

A continuación, detallamos algunos ejemplos que emplean las operaciones anteriores.
Al igual que con listas, las construcciones introducidas en los ejemplos serán explicadas en sus respectivas secciones.

\begin{lstlisting}
fun dif_sim (A: set of T, B: set of T) ret C: set of T
  C := (A $\cup$ B) - (A $\cap$ B)
end fun
\end{lstlisting}

La función \textit{dif\gbajo sim} calcula la diferencia simétrica de dos conjuntos.
La misma es un conjunto compuesto por todos los elementos que solo pertenecen a uno de los dos operandos. 

\begin{lstlisting}
fun inicializar_conjunto (n: nat) ret C: set of nat
  C := {}
  for i := 1 to n do
    C := C $\cup$ {i}
  od
end fun
\end{lstlisting}

La función \textit{inicializar\gbajo conjunto} construye un conjunto con los primeros \textit{n} números naturales.
Notar en esta función el uso del \textit{azúcar sintáctico} para definir conjuntos.
Simplemente se enumeran expresiones enceradas por llaves para denotar un conjunto.

\subsubsection{Tipo Tupla}

Un tipo \type{tuple} es una estructura compuesta por una cantidad fija de componentes, posiblemente de distintos tipos.
Cada componente se denomina \textit{campo}, y el identificador asociado a cada campo se le llama \textit{alias}.
Son utilizadas para empaquetar una serie de valores que se relacionan semánticamente.
La única operación disponible para trabajar con tuplas es la de obtener \textbf{.} un valor almacenado en la misma.
Dada una tupla \textit{t} y un alias \textit{a}, se puede acceder al campo asociado a ese alias con \textit{t\textbf{.}a}.

\begin{lstlisting}
var t: tuple
       inicial: char,
       edad: nat,
       peso: real
       end tuple
\end{lstlisting}

En el ejemplo, se declara una variable \textit{t} de tipo tupla.
Los alias son \textit{inicial}, que almacena un carácter, \textit{edad}, que almacena un natural, y \textit{peso}, que almacena un real.
Notar el uso de las palabras claves \textbf{tuple} y \textbf{end tuple} para definir la misma.

\begin{lstlisting}
t.inicial := 'm'
t.edad := 18
t.peso := 60.0
\end{lstlisting}

En el ejemplo anterior se almacenan distintos valores en los respectivos campos de la tupla previamente definida.
Las tuplas tienen gran importancia para definir tipos de datos abstractos.

\subsubsection{Tipo Puntero}

Un tipo \type{pointer} es una estructura compuesta por un solo componente.
Para el manejo dinámico de memoria se utilizan punteros.
Con los mismos se reserva, aloja y libera memoria para el componente apuntado por el puntero, a lo largo de la ejecución del programa.

\begin{lstlisting}
var p: pointer of nat
\end{lstlisting}

La declaración anterior crea una variable \textit{p} que será un puntero.
La misma servirá para direccionar un valor numérico natural en un futuro.
Antes de realizar cualquier asignación sobre \textit{p}, se deberá reservar memoria para el componente señalado, y una vez finalizado el cómputo se deberá liberar la memoria utilizada.

Asumiento que \textit{p} es un puntero, y que \textit{a} es un alias correspondiente a una posible tupla señalada por \textit{p}.
Las operaciones que manipulan punteros son las siguientes.

\begin{center}
\begin{tabular}{| c | l |}
\hline
     Operador & Descripción  \\
     \hline
     alloc(p) & Reserva espacio en memoria para almacenar el componente \\
     free(p) & Libera espacio en memoria apuntado por el puntero \\
     $\star$p & Devuelve el componente señalado en memoria \\
     p $\rightarrow$ a & Devuelve el campo asociado al alias de la tupla en memoria \\
     null & Constante que simboliza un puntero que no apunta a nada \\
\hline
\end{tabular}
\end{center}

Como se puede observar, los punteros permiten manejar explícitamente direcciones de memoria y sus contenidos, por lo que permiten programar a bajo nivel.
Al igual que las tuplas, los punteros tienen gran importancia a la hora de definir tipos de datos abstractos.
Como \Lang\space no posee \textit{garbage collector} es responsabilidad del programador administrar el uso de memoria del programa.

\begin{lstlisting}
alloc(p)
$\star$p := 20
free(p)
\end{lstlisting}

En el ejemplo anterior, se utiliza \textit{alloc} para reservar espacio en memoria para almacenar un valor natural y se coloca esa dirección en el puntero \textit{p}.
Luego, se almacena en esa misma dirección de memoria el valor \textit{20}.
Finalmente, se libera la memoria señalada por el puntero.

\subsection{Definición de Tipos}

Una característica muy importante de \Lang\space es la posibilidad de crear nuevos tipos de datos.
El lenguaje hace uso del tipado fuerte, es decir, toda expresión posee un tipo definido.
Debido a esto, se simplifica la interpretación del código y se fomenta la generación de código prolijo.
Pero al momento de querer resolver problemas de mayor complejidad, es necesario poder extender los tipos del lenguaje con otro más sofisticados y robustos.
Por lo tanto, \Lang\space ofrece ciertas construcciones con estos fines.

Para poder crear un nuevo tipo de datos se utiliza una sintaxis similar al siguiente ejemplo.
En el mismo, se utiliza la palabra clave \textbf{type} para señalar la creación de un sinónimo de tipo.
Le sucede el nuevo nombre de tipo, \textit{matriz} en el ejemplo, y finalmente un tipo concreto del lenguaje.

\begin{lstlisting}
type matriz = array[1..5, 1..5] of int
var M: matriz
\end{lstlisting}

Luego de la definición de tipo, se podrá utilizar el identificador \textit{matriz} como un tipo concreto del lenguaje a lo largo del programa.
El mismo, tendrá un comportamiento idéntico al arreglo al que se asoció.
Por último, se puede observar que una vez definidos se pueden declarar variables de los tipos creados.

En el lenguaje también se permite definir lo que comúnmente se llama \textit{tipos paramétricos}.
Esto es una forma de definir nuevos tipos de datos, de la forma más general posible.
Utilizando una variable de tipo (representada por un identificador), se puede crear un tipo nuevo donde su comportamiento no dependerá de la misma.

\begin{lstlisting}
type stack of T = list of T
\end{lstlisting}

En el ejemplo, se creó un nuevo tipo de dato denominado \textit{stack} (pila) que será una lista de tipo \textbf{T}.
Con esta definición genérica podemos definir las operaciones del nuevo tipo pila, cualquiera sea el valor de la variable \textbf{T}.

\begin{lstlisting}
proc empty (out p: stack of T)
  p := [ ]
end proc

proc push (in t: T, in/out p: stack of T)
  p := t $\triangleright$ p
end proc

fun top (p: stack of T) ret t: T
  t := head(p)
end fun

proc pop (in/out p: stack of T)
  p:= tail(p)
end proc

fun is_empty (p: stack of T) ret b: bool
  b := p = [ ]
end fun
\end{lstlisting}

Lo definido en el ejemplo, son todas las operaciones básicas de una pila.
El proceso \textit{empty} crea una pila vacía.
El proceso \textit{push} agrega un nuevo elemento al comienzo de la pila.
La función \textit{top} devuelve el primer elemento de la pila.
El proceso \textit{pop} elimina el primer elemento de la pila.
Y la función \textit{is\gbajo empty} pregunta si la pila está vacía.

Finalmente, hay que rescatar la posibilidad de definir tipos de datos recursivos.
Los mismos, son aquellos donde el nombre del nuevo tipo figura también en la definición del mismo.
Permitiendo definir así estructuras teóricamente infinitas.
A continuación se muestra un ejemplo que utiliza las tuplas y punteros descriptos previamente.

\begin{lstlisting}
type node = tuple
            value: nat,
            next: pointer of node
            end tuple
\end{lstlisting}

Para ilustrar, daremos un ejemplo donde se implementa una función que trabaja con el nuevo tipo de dato definido.
Se puede pensar a la estructura \textit{node} como una celda que almacena un valor natural y señala a otro \textit{node}, conformando así una posible lista abstracta.

\begin{lstlisting}
fun crear_lista_abs (n: nat) ret l : pointer of node
  var aux: pointer of node
  l := null
  for i := n downto 1 do
    alloc(aux)
    aux $\rightarrow$ value := i
    aux $\rightarrow$ next := l
    l := aux
  od
end fun
\end{lstlisting}

\section{Expresiones}

Las expresiones ocurren en asignaciones, en chequeos, y en pasaje de parámetros.
Están compuestas por operadores y operandos.
Producen un valor de cierto tipo, mediante la aplicación de los distintos operadores a sus respectivos operandos.
No alteran el estado del programa, ya que no producen efectos secundarios.

El lenguaje se basa en el tipado fuerte.
Esto significado que toda expresión posee un tipo, y el mismo debe ser adecuado al contexto en el que se utiliza.
En el hipotético caso en el que se intenta evaluar una expresión cuyo tipo no es el esperado, el programa no podría continuar su ejecución.

\subsection{Precedencia}

Los distintos operadores para cada uno de los tipos básicos y estructurados ya se vieron en sus respectivas secciones.
Cuando se emplean múltiples operadores en una expresión se utilizan las reglas de precedencia para determinar el orden de evaluación.
En \Lang\space no hay ninguna especificación sobre la precedencia de operadores.
A pesar de esto, se puede sugerir una tabla como la siguiente donde se utilizan las reglas clásicas de precedencia.

\begin{center}
\begin{tabular}{| c | c | c |}
\hline
    Operadores & Precedencia & Categoría  \\
    \hline
    \snot, $-$ & Primera & Operadores Unarios \\
    $*$, $/$, \sand & Segunda & Operadores Multiplicativos \\
    $+$, $-$, \sor & Tercera & Operadores Aditivos \\
    $=$, $<$, $>$ & Última & Operadores Comparativos \\
\hline
\end{tabular}
\end{center}

A la hora de evaluar una expresión, el intérprete se puede basar en las siguientes reglas.

\begin{itemize}
\item En operaciones con precedencias distintas, se evalúa primero la que tenga mayor precedencia.
\item En operaciones con precedencias iguales, se evalúa primero la que se encuentra antes en el código.
\item Si se utilizan paréntesis en expresiones, su contenido es evaluado primero.
\end{itemize}

\subsection{Conversiones}

A veces es necesario cambiar el tipo de una expresión, o una subexpresión, para poder hacer que la evaluación de la misma sea correcta.
Es decir, queremos realizar una conversión para que los tipos sean compatibles.

\begin{lstlisting}
var i: real
i := 1 + 2
\end{lstlisting}

Un ejemplo posible puede ser el anterior.
En el mismo tenemos una suma de números naturales, pero la variable a asignar es de tipo real.
En estas situaciones hay dos opciones.
Informamos al programador sobre un posible error de tipos, o se realiza una conversión \textit{implícita} del tipo de la expresión a un valor real.
En el lenguaje no hay ninguna especificación sobre si las conversiones implícitas o explícitas son posibles.
Esto comprende otra de las decisiones que se deberá tomar a la hora de la implementación del intérprete.

\subsection{Llamada a Funciones}

Las llamadas a funciones comprenden otra parte de las expresiones.
En las mismas se denota el identificador correspondiente a la función que se desea ejecutar, y luego se listan entre paréntesis todos los parámetros actuales de la misma.
Obviamente, los tipos de los parámetros y el del resultado devuelto por la función
deben ser los esperados.
En el siguiente ejemplo, se llama a la función \textit{inicializar\gbajo lista} con el valor natural \textit{5}, y el resultado es asignado a la variable \textit{L}.

\begin{lstlisting}
var L: list of nat
L := inicializar_lista(5)
\end{lstlisting}

\section{Declaración de Variables}

Como todo lenguaje imperativo, \Lang\space permite declaración de variables.
Una variable representa un lugar en memoria explícitamente nombrado, que almacena un valor de cierto tipo.
Para crear una variable nueva se utiliza la palabra clave \textbf{var}, seguida del identificador de variable y su tipo.
En el siguiente ejemplo, se declara una variable de tipo natural llamada \textit{i}, y una variable de tipo bool llamada \textit{j}.

\begin{lstlisting}
var i: nat
var j: bool
\end{lstlisting}

En el lenguaje, las variable no son inicializadas luego de su declaración.
Es responsabilidad del programador asignarles un valor inicial correspondientes a las mismas.
Si en una hipotética ejecución del programa, se utiliza una variable sin inicialización entonces no se puede continuar con la ejecución del mismo.

Una característica de \Lang\space es la capacidad de declarar múltiples variables del mismo tipo en una línea.
En el siguiente ejemplo, se declaran dos variables nuevas, \textit{aux} y \textit{tmp} de tipo real.

\begin{lstlisting}
var aux, tmp: real
\end{lstlisting}

Las variables obedecen las reglas de \textit{scope}.
Esto significa que la existencia de las mismas se extiende hasta el fin del bloque de código en el que fueron declaradas.
Debido a esto, se puede utilizar el mismo identificador para variables diferentes, siempre y cuando el alcance de las mismas sea distinto.
Otro detalle sobre esto es que en el lenguaje no se utilizan variables globales, por lo que todas las variables son locales al bloque de código en el que fueron declaradas.

Un aspecto que no se encuentra especificado en el lenguaje es si se permite intercalar declaración de variables con sentencias del programa.
En una primera instancia, sería preferible que un programa se pueda dividir en una sección de declaraciones y otra sección de sentencias para facilitar la comprensión del código.
Esto comprenderá otra decisión a tomar en la implementación del intérprete.

Hay distintas categorías de variables en el lenguaje.
Las variables se pueden dividir en cuatro clases en base a como se accede a la memoria representado por las mismas:

\begin{itemize}
\item \textbf{Variables Enteras} son representadas en su totalidad por un identificador. Es decir, poseen un único lugar en memoria.

\begin{lstlisting}
var pi: real
pi := 3.14
\end{lstlisting}

\item \textbf{Variables Indexadas} para obtener un componente de un arreglo se indexa de forma apropiada la variable que denota al mismo.

\begin{lstlisting}
var A: array [1..5] of bool
A[1] := True
A[2] := False
\end{lstlisting}

\item \textbf{Variables de Campo} para obtener un componente de una estructura se especifica el alias correspondiente al campo requerido.

\begin{lstlisting}
var person: tuple inic char, edad: nat end tuple
person.inic := 'm'
person.edad := 18
\end{lstlisting}

\item \textbf{Variables Referenciadas} para acceder al valor señalado por un puntero, se utiliza el operador de acceso con la variable que denota al puntero.

\begin{lstlisting}
var p: pointer of char
alloc(p)
$\star$p := 'g'
free(p)
\end{lstlisting}

\end{itemize}

\section{Sentencias}

La esencia de un algoritmo son las acciones que realiza.
Estas acciones están contenidas en las sentencias del programa, las cuales se dicen ser ejecutables.
Las mismas se dividen en sentencias simples, y sentencias estructuradas.

\subsection{Sentencias Simples}

Una sentencias simple es una sentencia cuyas partes no constituyen otras sentencias.
Básicamente, son sentencias \textit{atómicas} que forman la base para la construcción de las sentencias estructuradas.

\subsubsection{Asignación}

Las asignaciones le dan un valor a las variables, remplazando cualquier valor previo que pueden haber tenido.
Se utiliza el símbolo \textbf{:=}, precedido por el identificador de la variable y sucedido por una expresión cuyo valor sea del mismo tipo que la variable a asignar.
En el ejemplo, se asigna el valor \textit{1} a la variable de tipo natural \textit{i}, y el valor \textit{True} a la variable booleana \textit{j}.

\begin{lstlisting}
var i: nat
var j: bool
i := 1
j := True
\end{lstlisting}

La noción de estado es un concepto fundamental para la programación imperativa.
Las variables son utilizadas para almacenar los resultados de la computación del programa.
En el siguiente ejemplo, se evalúa la expresión de la derecha de la asignación y el resultado de la misma es almacenado en la variable booleana \textit{j}.
El valor final del la variable booleana es \textit{False}.

\begin{lstlisting}
j := j $\land$ (i > 1)
\end{lstlisting}

\subsubsection{Llamada a Procedimientos}

Las llamadas a subrutinas comprenden otra de las sentencias simples.
En la misma se denota el identificador correspondiente al procedimiento, y luego se listan entre paréntesis todos los parámetros actuales del mismo.
Suponiendo que definimos un procedimiento para ordenar los valores de un arreglo \textit{selection\gbajo sort}, y tenemos un arreglo \textit{A} de enteros, podemos realizar lo siguiente para invocar al procedimiento.

\begin{lstlisting}
selection_sort(A)
\end{lstlisting}

\subsubsection{Skip}

La sentencia \textit{skip} se ha utilizado históricamente en distintos lenguajes de programación para indicar la no realización de ninguna computación.
En nuestro lenguaje esta instrucción no presenta ninguna utilidad.
Se emplea por fines de claridad en la descripción de distintos algoritmos.
No realiza ninguna evaluación y tampoco tiene efectos secundarios.

\begin{lstlisting}
skip
\end{lstlisting}

\subsection{Sentencias Estructuradas}

Las sentencias estructuradas son construcciones compuestas por otras sentencias que pueden ser ejecutadas en secuencia, condicionalmente o repetidamente.
Se pueden dividir en sentencias secuenciales, condicionales, e iterativas.

\subsubsection{Sentencias Secuenciales}

Muchos lenguajes de programación permiten la creación de \textit{bloques de código}, compuestos por una serie de sentencias.
Las mismas se deben de ejecutar de forma secuencial en el orden que aparecen en el código.
En \Lang\space no existe ninguna construcción explícita para denotar estas construcciones, pero si se pueden especificar secuencias de sentencias como en el siguiente ejemplo.
En el mismo, se separan las distintas sentencias en líneas diferentes.

\begin{lstlisting}
minp := min_pos_from(A, i)
swap(A, i, minp)
i := i + 1
\end{lstlisting}

El ejemplo anterior es un fragmento de un algoritmo de ordenación, \textit{selection\gbajo sort}.
En el mismo se realiza una asignación, una llamada a un proceso y finalmente otra asignación.
Los identificadores \textit{minp} e \textit{i} son variables de tipo natural y \textit{A} es un arreglo, mientras que \textit{min\gbajo pos\gbajo from} y \textit{swap} denotan una función y un procedimiento respectivamente.

\subsubsection{Sentencias Condicionales}

Todo lenguaje imperativo implementa algún tipo de sentencia condicional.
La misma sirve para realizar ejecuciones diferentes dependiendo del valor de una condición.

\begin{lstlisting}
if i < n then
  minp := min_pos_from(A, i)
  swap(A, i, minp)
  i := i + 1
fi
\end{lstlisting}

En el ejemplo, si el valor de la variable \textit{i} es menor al de \textit{n} se ejecutará el bloque de código dentro del condicional.
Caso contrario, las sentencias que se encuentran dentro del \textit{if} no serán ejecutadas.

Para la sentencia condicional básica se usa la palabra clave \textbf{if} seguida de una expresión booleana (también denominada \textit{guarda}), sucedida por la palabra clave \textbf{then} y finalmente las instrucciones a ejecutar en el caso que la condición se cumpla.
El bloque condicional finaliza con la palabra clave \textbf{fi}.

Además de la sentencia condicional compacta que vimos anteriormente, el lenguaje posee otros tipos más complejos de construcciones condicionales.
Para el caso de querer realizar una división del flujo de ejecución más refinada se pueden especificar múltiples guardas utilizando \textbf{else if} e incluso se puede hacer uso de la palabra clave \textbf{else} para ejecutar un bloque de código cuando todas las demás guardas resultaron falsas.

\begin{lstlisting}
var menor, igual, mayor: bool
menor := False
igual := False
mayor := False
if i < j then
  menor := True
else if i > j then
  mayor := True
else
  igual := True
fi
\end{lstlisting}

En el ejemplo se evalúa si la variable \textit{i} es menor, mayor o igual a la variable \textit{j}.
Debido a que la ejecución del programa es secuencial se ejecutará el bloque de código cuya guarda sea la primera en ser satisfecha.
Luego de esto, el programa saltará al final del condicional ignorando todas las otras guardas con sus respectivas instrucciones.

Finalmente, en el lenguaje se ofrece una sintaxis alternativa a la anterior pero que posee el mismo significado semántico.
A continuación implementaremos la sentencia condicional anterior, pero utilizando esta sintaxis alternativa.

\begin{lstlisting}
if i < j $\rightarrow$
  menor := True
else if i > j $\rightarrow$
  mayor := True
otherwise
  igual := True
fi
\end{lstlisting}

\subsubsection{Sentencias Iteradoras}

Las sentencias más importantes de un lenguaje imperativo son las que permiten ejecutar un conjunto de instrucciones una cantidad finita o infinita de veces.
\Lang\space ofrece una amplia variedad de estas construcciones.

\begin{lstlisting}
var A: array[1..5] of int
var i: nat
i := 1
while i $\leq$ 5 do
  A[i] := 1
  i := i + 1
od
\end{lstlisting}

El ejemplo inicializa los valores del arreglo en \textit{1}.
Esto lo hace, creando una variable \textit{i} que toma distintos valores en el conjunto de índices del arreglo \textit{A} e irá inicializando los valores del mismo.
Notar que la sintaxis de esta instrucción consiste de la palabra clave \textbf{while} seguida de una expresión booleana (también denominada \textit{guarda}), y luego un bloque de código encerrado entre las palabras claves \textbf{do} y \textbf{od}.

Al igual que con las sentencias condicionales, en el lenguaje se ofrece una sintaxis alternativa para las sentencias iterativas.
A continuación, implementamos el iterador anterior haciendo uso de la sintaxis alternativa.

\begin{lstlisting}
do i $\leq$ 5 $\rightarrow$
  A[i] := 1
  i := i + 1
od
\end{lstlisting}

La semántica intuitiva de esta construcción es la ejecución reiterada del bloque de código mientras la expresión booleana sea verdadera
Esta abstracción nos permite realizar una serie de cambios de estados hasta obtener un resultado, momento donde la guarda deja de valer.

En otras situaciones, interesa ejecutar un conjunto de sentencias para distintos valores de una variable en un rango determinado.
Es decir, si se quiere realizar de forma reiterativa ciertos cambios de estados conociendo de antemano la cantidad de veces que queremos iterar.

\begin{lstlisting}
var A: array[1..5] of int
for i := 1 to 5 do
  A[i] := 1
od
\end{lstlisting}

Notar que con la sentencia \textbf{for}, uno puede especificar los límites de valores que puede tomar cierta variable dentro de su bloque.
Hay una serie de consideraciones a tener en cuenta al utilizar esta instrucción.

\begin{itemize}
\item La variable a iterar es declarada de forma implícita en el mismo \textbf{for}, por lo que no es necesario especificar su tipo.
En una futura implementación del lenguaje, se deberá tomar una decisión sobre si el tipo es inferido o debe ser especificado.
\item El alcance (\textit{scope}) estará restringido al bloque de la sentencia.
Esto significa que una vez finalizada la ejecución de la instrucción la variable \textit{i} dejará de ser accesible.
\item En el cuerpo del \textbf{for} no se modificará el valor de la variable a iterar.
La alteración del estado de \textit{i} solo se realiza de forma implícita al finalizar cada iteración.
\end{itemize}

Hay más versiones de la sentencia \textbf{for}.
A continuación haremos mención de cada una de estas, y describiremos intuitivamente su funcionamiento.
Este iterador comprende una de las construcciones polimórficas del lenguaje.

\begin{lstlisting}
var A: array[1..5] of int
for i := 5 downto 1 do
  A[i] := 1
od
\end{lstlisting}

La semántica de este ejemplo es la misma a todos los ejemplos anteriores.
La particularidad es que se puede especificar un rango descendente de valores para la variable de control.
En los anteriores, \textit{i} tomaba valores de forma ascendente.

Otra característica muy interesante, es que la instrucción \textbf{for} permite definir cualquier tipo enumerable para la variable iteradora.
Esto permite que los límites de valores para la variable de control no sean estrictamente numéricos.
Todo conjunto de valores que pueda ser enumerado puede ser utilizado para especificar los límites de la iteración.

\begin{lstlisting}
var B: array['a'..'e'] of int
for k := 'a' to 'e' do
  B[k] := 1
od
\end{lstlisting}

Notar que para este ejemplo, se puede inferir el tipo de la variable \textit{k} sin necesidad de especificar el mismo.
En cambio para los ejemplos anteriores, con los límites \textit{1} a \textit{5} no queda claro si se refieren a los números naturales o a los enteros.

Finalmente, describiremos el uso de un iterador un poco más abstracto.
Es muy común cuando trabajamos con arreglos (o listas) acceder a los diferentes valores del mismo y operar luego con estos.
Para tener un código con mayor nivel de abstracción, se puede usar algo similar al ejemplo siguiente.

\begin{lstlisting}
var sumatoria: int
sumatoria := 0
for a $\in$ A do
  sumatoria := sumatoria + a
od
\end{lstlisting}

Asumiendo que \textit{A} es un arreglo de enteros.
Este ejemplo suma todos los elementos del mismo.
Dado que solo nos interesan los valores que almacena el arreglo, podemos calcular la sumatoria iterando directamente sobre el arreglo, ignorando de esta manera los índices.

\section{Funciones}

Para definir rutinas determinísticas, es decir, secuencias de instrucciones que no dependen del estado del programa, \Lang\space ofrece la posibilidad de especificar funciones.
Las mismas realizan una computación, en base a un conjunto de parámetros, y devuelven un resultado.
Las funciones son independientes del estado del programa, en el sentido que su comportamiento es determinado por los valores de entrada que recibe.
Es importante notar que no modifican el estado de las variables que son pasadas como parámetros.

\begin{lstlisting}
fun factorial (n: nat) ret fact: nat
  fact := 1
  for i := 1 to n do
    fact := fact * i
  od
end fun
\end{lstlisting}

En el ejemplo, se especifica una función que calcula el factorial de un número natural \textit{n}.
La variable \textit{i} tomará distintos valores de \textit{1} hasta \textit{n}, mientras que en la variable \textit{fact} se irá almacenando la productoria de estos números.

Para la sintaxis, se usa la palabra clave \textbf{fun} seguida del nombre de la función.
Luego, entre paréntesis se especifican los parámetros de entrada separados por comas.
Se tienen que detallar los tipos y los identificadores para cada una de las entradas que necesitará la función para su cómputo.
También se suelen denominar \textit{parámetros formales}.
Con la palabra clave \textbf{ret} se especifica el valor de retorno, además del nombre y tipo de la variable asociada al mismo.
Finalmente, en el cuerpo de la función se pueden usar todas las sentencias y expresiones que vimos hasta ahora para escribir el programa deseado.
Para cerrar el bloque de la función, se utiliza \textbf{end fun}.

Sobre los identificadores de funciones y sus variables, no hay ninguna restricción especificada.
Para la implementación del intérprete se deberá tomar una decisión sobre que nombres son válidos y en base a qué criterios se permitirán los mismos.
Obviamente, no se podrán definir identificadores que también representen palabras claves.

\begin{lstlisting}
fun es_par (n: nat) ret b: bool
  b := (n % 2) = 0
end fun

fun existe_par (A: array[1..n] of nat) ret b: bool
  b := False
  for a $\in$ A do
    b := b $\lor$ es_par(a)
  od
end fun
\end{lstlisting}

En este último ejemplo se ilustran un par de características de las funciones.
La función \textit{es\gbajo par} calcula si un numero natural pasado como parámetro es par.
En cambio, \textit{existe\gbajo par} chequea si existe algún número par en el arreglo pasado como parámetro.
Notar que para los arreglos, uno puede establecer límites fijos como en el caso del límite inferior \textit{1}, o límites variables \textit{n}.
También se ve que para llamar una función anteriormente definida solo se especifica el nombre seguido entre paréntesis de todos sus parámetros.

Las funciones también pueden ser definidas de forma recursiva.
Es decir, que en el mismo cuerpo de la función se puede llamar a sí misma para continuar con la computación.

\begin{lstlisting}
fun es_par (n: nat) ret b: bool
  if n = 0 then
    b := True
  else if n = 1 then
    b := False
  else
    b := es_par(n - 2)
  fi
end fun
\end{lstlisting}

Este ejemplo muestra una manera no recomendable de definir la función \textit{es\gbajo par} utilizando recursión.
Se definen los dos casos bases, cuando \textit{n} es \textit{0} o \textit{1} y si no se cumple ninguno se decrementa la variable en \textit{2} realizando la llamada recursiva.

Finalmente, una última característica importante de las funciones es la definición polimórfica.
En la misma, uno no especifica de manera concreta los tipos de las variables sino que utiliza una variable de tipo para poder crear una función cuya implementación pueda ser usada por más de un tipo.

\begin{lstlisting}
fun indice_minimo (A: array[1..n] of T) ret min: nat
  min := 1
  for i := 1 to n do
    if A[i] < A[min] then
      min := i
    fi
  od
end fun
\end{lstlisting}

La función devuelve el índice en el arreglo del valor más chico.
Se puede ver que se utiliza la variable de tipo \textbf{T} para especificar que la función puede tomar valores de cualquier tipo.
En particular, esta función puede ser usada para encontrar el índice del mínimo de un arreglo de enteros, caracteres, naturales, entre otros (siempre y cuando la comparación esté definida para el conjunto de valores).

Una salvedad importante sobre las variables de tipos, es que no siempre pueden tomar \textit{cualquier} tipo concreto.
Usando el ejemplo anterior, la variable \textbf{T} no podría ser de tipo booleano.
Esto se debe a que se utilizan operaciones de comparación entre valores de tipo \textbf{T}, y para los booleanos estas no están definidas.
Esto comprenderá otra de las decisiones que se deberá tomar a la hora de la implementación del intérprete.

\section{Procedimientos}

Una construcción similar a las funciones son los procedimientos.
Ambas representan formas de especificar rutinas reusables para realizar tareas particulares.
Pero la diferencia fundamental entre ambos es que los procedimientos pueden modificar el estado del programa en su accionar.
En base a un conjunto de parámetros (algunos de entrada, y otros de salida), un procedimiento realiza una computación que modificará el entorno del proceso que lo llamó.

\begin{lstlisting}
proc p_sumatoria (in a, b: nat, out k: nat)
  var sum: nat
  sum := 0
  for i := a to b do
    sum := sum + i
  od
  k := sum
end proc

fun f_sumatoria (a, b: nat) ret k: nat
  k := 0
  for i := a to b do
    k := k + i
  od
end fun
\end{lstlisting}

Este ejemplo, muestra un programa donde se define una función \textit{f\gbajo sumatoria} y un procedimiento \textit{p\gbajo sumatoria} que hacen prácticamente lo mismo.
Calcular la sumatoria de los números naturales desde \textit{a} hasta \textit{b}.
La diferencia fundamental en estas dos construcciones es que la función devuelve un valor (el cual está almacenado en la variable local \textit{k}), en cambio, el procedimiento está modificando el valor de una variable global \textit{k}, que fue definida fuera del mismo.

La sintaxis de un procedimiento es similar al de una función salvo por el uso de las palabras claves \textbf{proc} y \textbf{end proc} que encierran al mismo, y la especificación de entradas y salidas.
Para cada parámetro formal del procedimiento hay tres opciones:

\begin{itemize}
\item \textbf{in} determina que las variables de entrada serán utilizadas solo para lectura.
Por lo tanto, su valor no será modificado.
\item \textbf{out} significa que el valor asociado a la variable será alterado por la llamada al procedimiento.
Su valor no será utilizado para la evaluación de una expresión.
\item \textbf{in / out} establece que la variable va a ser empleada para lectura y escritura.
Su valor inicial determinará la computación, pero el mismo será modificado a lo largo del procedimiento.
\end{itemize}

Al igual que en las funciones, los procedimientos permiten polimorfismo de la misma forma.
En el siguiente ejemplo, se modifica un arreglo permutando los valores en las posiciones \textit{i} y \textit{j}.
Notar que la variable de tipo \textbf{T}, se utiliza tanto en la especificación de parámetros como en la variable temporal dentro del procedimiento.

\begin{lstlisting}
proc swap (in/out A: array[1..n] of T, in i, j: nat)
  var tmp: T
  tmp := A[i]
  A[i] := A[j]
  A[j] := tmp
end proc
\end{lstlisting}

Para contextualizar mejor el uso de procedimientos podemos observar el siguiente ejemplo.
En el mismo se utilizará \textit{swap} para invertir un arreglo.
Se puede apreciar que luego de llamar al procedimiento auxiliar no se realiza ninguna asignación debido a que el valor del arreglo \textit{A} es modificado de forma implícita por el mismo.

\begin{lstlisting}
proc invertir_arreglo (in/out A: array[1..n] of T)
  for i := 1 to n / 2 do
    swap(A, i, n + 1 - i)
  od
end proc
\end{lstlisting}

Finalmente, y similar a funciones, se permite la definición de procedimientos recursivos.
A continuación especificaremos el procedimiento análogo a la función \textit{es\gbajo par} implementada anteriormente.

\begin{lstlisting}
proc es_par (in n: nat, out b: bool)
  if n = 0 then
    b := True
  else if n = 1 then
    b := False
  else
    es_par(n, b)
  fi
end proc
\end{lstlisting}

\section{Programas}

Para finalizar, vamos a describir como se define un programa en \Lang.
Como muchas de las características del lenguaje, no hay ninguna especificación precisa de la misma.
Debido a esto, la siguiente descripción puede estar sujeta a modificaciones.

Para ejemplificar, vamos a implementar uno de los primeros algoritmos de ordenación vistos en la materia \textit{selection\gbajo sort}.
Algunas de las componentes del programa ya se ilustraron en secciones anteriores.

\begin{lstlisting}
proc swap (in/out A: array[1..n] of T, in i, j: nat)
  var tmp: T
  tmp := A[i]
  A[i] := A[j]
  A[j] := tmp
end proc

fun min_pos (A: array[1..n] of T, i: nat) ret mp: nat
  mp := i
  for j := i + 1 to n do
    if A[j] < A[mp] then
      mp := j
    fi
  od
end fun

proc selection_sort (in/out A: array[1..n] of T)
  var minp: nat
  for i := 1 to n-1 do
    minp := min_pos(A, i)
    swap(A, i, minp)
  od
end proc
\end{lstlisting}

En el ejemplo se define un proceso \textit{swap} que se encarga de intercambiar los valores de dos posiciones de un arreglo.
La función \textit{min\gbajo pos} calcula la posición del valor más chico entre un índice intermedio y el índice final del arreglo.
El procedimiento \textit{selection\gbajo sort} es el encargado de ordenar el arreglo llamando a los dos métodos auxiliares anteriores.

Un programa se describe en una serie de funciones y/o procedimientos que se especifican uno seguido del otro.
No hay ninguna restricción sobre el orden en el que deben ser definidos.
Ya que un programa de \Lang\space no puede ser ejecutado, no es necesario definir una función \textit{main} como en C, o especificar sentencias fuera de cualquier bloque de código como en Python.
En definitiva, un programa en nuestro lenguaje se ejecuta \textit{en el aire}.
Nuestro objetivo va a ser convertir los programas de \Lang\space en programas ejecutables.

Una última tarea es definir como se crean nuevos tipos de datos en nuestros programas.
De vuelta, debido a la falta de especificación, propondremos nuestra propia idea.
Al comienzo de todo programa se realizarán las declaraciones de nuevos tipos de datos y, luego de las mismas, se especificarán todas las funciones y/o procedimientos que emplean a los mismos.

\begin{lstlisting}
type counter = nat

proc init (out c: counter)
  c := 0
end proc

proc inc (in/out c: counter)
  c := c + 1
end proc

proc dec (in/out c: counter)
  c := c - 1
end proc

fun is_init (c: counter) ret b: bool
  b := c = 0
end fun
\end{lstlisting}

En este ejemplo, se creó un tipo de datos \textit{counter} el cual se utiliza justamente para contar.
Posee los procedimientos para inicializarlo \textit{init}, para aumentarlo \textit{inc} y decrementarlo \textit{dec}.
También se define la función que pregunta si es inicial \textit{is\gbajo init}.

\end{document}
