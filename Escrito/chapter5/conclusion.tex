% Conclusión
En este trabajo final hemos definido formalmente e implementado un nuevo lenguaje.
Se han descripto las motivaciones principales que justificaron su creación, y se hizo mención de los elementos más relevantes que lo definen.
% IDEA: Junto a esto, con una serie de ejemplos sobre casos de uso y explicaciones informales, se han expuesto las diversas construcciones que ofrece el lenguaje.
Desde un punto de vista formal, las contribuciones de la tesis se pueden resumir en:

\begin{itemize}
\item
La definición informal de las características deseables para una primera versión del lenguaje.
% IDEA: La formalización de una primera versión para un lenguaje de programación que podrá ser utilizada en la formación de estudiantes en la carrera.
Se estudiaron de manera exhaustiva los ejemplos del pseudocódigo de la materia, donde se hizo un resumen con todas las construcciones empleadas en el mismo, con lo que se obtuvo una primera noción de un lenguaje con muchas características interesantes.
Algunas de las cuales son el polimorfismo paramétrico y \textit{ad hoc}, la posibilidad de emplear distintos tipos de valores para delimitar los índices válidos de arreglos, la capacidad de declarar instancias de clases, y la definición de estructuras iterables.
% IDEA: Algunas de las cuales son la inclusión de tipos como los \textit{conjuntos} y las \textit{listas}, la posibilidad de emplear distintos tipos de valores para delimitar los índices válidos de arreglos, y la declaración de estructuras iterables.
% IDEA: ...de un lenguaje demasiado complejo.
% IDEA: A través de la formalización se fue refinando en un lenguaje manejable, que resultara práctico para el uso de la asignatura.
% IDEA: Abarcativo / Amplio
% IDEA: Partiendo de una definición incompleta e imprecisa de un pseudocódigo, se logró diseñar un lenguaje inspirado en el mismo.
\item
La definición de su sintaxis, abstracta y concreta, lo cual permite establecer de manera precisa la forma de escribir programas en el lenguaje.
A través de las gramáticas correspondientes, logramos eliminar las ambigüedades presentes en determinadas estructuras sintácticas del pseudocódigo.
% IDEA: De alguna manera esta etapa fue un primer lugar donde se empezó a recortar la idea original del lenguaje que se había pensado luego de estudiar en profundidad el pseudocódigo.
% IDEA: De alguna manera esta etapa representó otra instancia para delimitar el alcance deseado de nuestro lenguaje.
% IDEA: Eliminar las ambigüedades del lenguaje que surgían durante el desarrollo de la asignatura.
\item
La definición de los chequeos estáticos, que determinan cuando un programa está bien tipado antes de su ejecución.
Para el caso del chequeo de tipos, se definen varias clases de \textit{juicios de tipado} con sus respectivas reglas.
% IDEA: ...se definieron formalmente los chequeos a efectuar de manera estática.
Los chequeos no solo se limitan a verificaciones de tipo, también se analiza el uso adecuado de variables donde se evita la lectura o escritura de variables que no soportan las respectivas acciones.
% IDEA: ...han sido declaradas para estas acciones.
% IDEA: ...con estos fines.
% IDEA: ...donde se evita la escritura de variables de lectura y la lectura de variables de escritura.
% IDEA: ...la declaración de funciones y procedimientos previo a su llamado, la unicidad de los identificadores para nombrar construcciones del lenguaje, entre otras.
% IDEA: En definitiva hemos definido \textit{juicios} para verificar de manera estática todas las propiedades necesarias que debe satisfacer un programa, donde también se han definido contextos adecuados para almacenar la información recopilada durante su análisis.
% IDEA: Definiendo \textit{juicios de tipado} con sus respectivas reglas se definieron formalmente los chequeos a efectuar.
\end{itemize}

Sumado al desarrollo matemático, realizamos la primer iteración en la implementación del lenguaje; donde utilizando la formalización como base, se han implementado las correspondientes etapas de \textit{parser} y \textit{chequeos estáticos}.
Respecto a la implementación, las contribuciones del trabajo son:

\begin{itemize}
\item
La implementación de las fases de \textit{análisis léxico} y \textit{análisis sintáctico}.
% IDEA: ...las cuales fueron desarrolladas de manera simultánea.
Los principales desafíos fueron adecuar la librería \Parsec{} a las necesidades de la implementación, y la posterior transición a la librería \Megaparsec{}.
Se estudiaron distintas opciones para la implementación de la sintaxis, la cual finalmente se adaptó al tipo de datos \lstinline[style = haskell]{Located}.
Permitiendo de esta manera almacenar la información de posición de todas las construcciones sintácticas relevantes, y facilitar la generación de mensajes de error precisos.
% IDEA: Se adaptó la sintaxis de manera de poder almacenar la información de posición en todas las construcciones sintácticas relevantes, lo cual permite la generación de mensajes de error precisos.
\item
La implementación de los chequeos estáticos, que comprenden las verificaciones estáticas que se realizan previa la ejecución de un programa.
% IDEA: Utilizando la definición formal como base...
Utilizando como guía el trabajo~\cite{MonadicTC}, y la formalización de los \textit{juicios de tipado}, se desarrolló una primera implementación incompleta del lenguaje.
La transición del formalismo a la implementación fue casi directa, salvo por las dificultades encontradas en el algoritmo de unificación para inferir tipos, y el subtipado para los tipos numéricos.
% IDEA: La transición del formalismo a la implementación fue casi directa, salvo por las dificultades para diferenciar clases de identificadores, el agregado de mensajes de advertencia, y la complejidad del algoritmo de unificación para inferir tipos en determinados contextos.

\iffalse
% Demasiados detalles...
Se empleó la mónada \lstinline[style = haskell]{RWST} para diseñar los chequeos estáticos del proyecto; donde el \textit{estado} consistía de los contextos formalizados, el \textit{entorno} indica el alcance de análisis actual, y la \textit{salida} es el listado de advertencias generadas durante el análisis.
\fi
% IDEA: ...y la manipulación de información de posición al generar un error estático.
% IDEA: Se emplea el mismo identificador para tamaños dinámicos y variables. (Identificadores)
% IDEA: Se debieron agregar verificaciones adicionales. (Advertencias)
% IDEA: Invariantes...
% IDEA: Se debieron adaptar los \textit{juicios de tipado} formalizados al código del proyecto, ...
\end{itemize}

\section{Trabajos Futuros}

El diseño del lenguaje aún está lejos de estar terminado, ya que este trabajo solo comprendió la primer etapa de su desarrollo.
Una importante tarea a realizar será definir matemáticamente la semántica dinámica que nos permita ejecutar programas; probablemente utilizando una semántica operacional \textit{small step} para poder ejecutar paso a paso un programa.
% IDEA: Por lo tanto, a continuación describiremos distintas tareas para realizar a futuro, con el fin de cumplir nuestro objetivo.
% IDEA: Algunas tareas para realizar a futuro estarán destinadas a completar la formalización restante del lenguaje, siguiendo con las fases posteriores necesarias para su definición; mientras otras podrán ser realizadas con la finalidad de mejorar y expandir sus funcionalidades actuales.

\iffalse
% Semántica Dinámica
\subsection{Semántica Dinámica}

Hasta ahora solo hemos trabajado en la etapa de \textit{análisis} del lenguaje.
Partiendo de un archivo de texto, somos capaces de obtener la estructura sintáctica de un programa, y verificar de forma \textit{estática} las distintas propiedades semánticas necesarias.
Debemos pasar a una nueva etapa, la fase de \textit{síntesis}.
Utilizando la representación intermedia obtenida previamente, queremos tener la capacidad de realizar una ejecución del programa provisto, y durante la misma, también poder validar de forma \textit{dinámica} ciertas condiciones necesarias para asegurar su correcto funcionamiento.
% IDEA: Sumado a todo esto, es indispensable diseñar un medio de interacción para que el programador pueda comunicarse con nuestro intérprete.
% IDEA: El desarrollo de una \textit{interfaz de usuario} es otro aspecto fundamental para la implementación del programa, y su posterior aplicación en el dictado de la asignatura.

\subsubsection{Síntesis}

La etapa de \textit{síntesis} comprende todos los aspectos \textit{dinámicos} sobre la ejecución de un programa.
Comenzando con el \textit{árbol de sintaxis abstracta} obtenido durante el \textit{análisis} del código, debemos simular la ejecución del programa en base a los datos de entrada provistos por el usuario.
Para poder realizar esta acción, necesitaremos definir formalmente la semántica \textit{small step} del lenguaje; la cual facilitará los medios necesarios para examinar detalles particulares sobre el orden de evaluación de las distintas construcciones especificadas en el código.
Esto nos permitirá efectuar una por una las instrucciones del programa, al mismo tiempo que se exhiben los estados intermedios obtenidos durante su computación.

Sumado a lo anterior, durante la ejecución del código, es necesario llevar a cabo la validación \textit{dinámica} del mismo.
Debido que la totalidad de errores de un programa no puede ser detectada de forma \textit{estática}, hay ciertas verificaciones que son realizadas durante esta etapa.
Las mismas consistirán en su mayoría de asegurar el uso adecuado de memoria por parte del usuario.
Ya sea para liberar o reservar memoria mediante el empleo de punteros, o incluso el acceso a ciertas ubicaciones de memoria representadas por variables, es fundamental asegurar que la ejecución del programa se pueda realizar de forma consistente, y que no se presenten comportamientos inesperados durante la misma.
\fi

\subsection{Enriquecer el Lenguaje}

Existen una serie de características que fueron consideradas a lo largo del desarrollo de este trabajo, pero que no llegaron a ser incluidas en esta primera versión del lenguaje.
% IDEA: Las mismas fueron relegadas por diversos motivos a medida que se avanzó en el refinamiento de la idea original.
% IDEA: Algunas debieron ser omitidas por falta de tiempo, otras a causa de no poder llegar a un concenso en su diseño, e incluso algunas por las dificultades encontradas durante su implementación.
A continuación daremos una breve descripción de cada una de estas, junto con sugerencias para facilitar su futura incorporación.

\subsubsection{Soporte para Múltiples Módulos}

Nuestro lenguaje solo permite definir programas en un único contexto.
% IDEA: Esto puede no ser un limitante en el poder expresivo del lenguaje, pero si...
Lo cual resulta un inconveniente para su incorporación en el dictado de la materia.
Debido que durante la asignatura se hace hincapié en la importancia de la separación de los módulos para la especificación de \textit{tipos abstracto de datos}, y los correspondientes a su implementación, es fundamental que el lenguaje provea las herramientas necesarias para mantener esa abstracción mediante el encapsulamiento de las construcciones involucradas.

Para incorporar esta funcionalidad, se deberá determinar la sintaxis adecuada para poder importar y exportar tipos, funciones, y procedimientos definidos dentro de un determinado módulo.
Sumado a esto, se tendrán que adaptar los chequeos estáticos para soportar estas nuevas situaciones.
En particular los sinónimos de tipos actualmente son interpretados como una definición transparente, donde idealmente quisiéramos que su definición se vuelva opaca fuera del módulo en el que fueron declarados.
Respecto a la implementación, se deberá adaptar la información de posición \lstinline[style = haskell]{Info} para almacenar además, el nombre del archivo \lstinline[style = haskell]{File} correspondiente a la ocurrencia del elemento sintáctico analizado.
% IDEA: ...similar a como lo hace \Haskell{} cuando se declaran con \lstinline[style = haskell]{type}.
% IDEA: ...o incluso reproducir un comportamiento parecido a \lstinline[style = haskell]{newtype} en \Haskell{}; lo cual también permitiría declarar nuevas instancias de clase para el tipo aludido.

\subsubsection{Clases e Instancias}

Actualmente en el lenguaje solo hay definidas dos clases, \textbf{Eq} y \textbf{Ord}.
Las cuales representan a los tipos que permiten comparaciones entre sus valores, ya sea en base a su igualdad en el caso de la primera, o según su orden para la segunda.
Una posible expansión del lenguaje sería el agregado de nuevas clases nativas.
% IDEA: Hay una posibilidad que en un futuro resulte útil añadir nuevas clases al lenguaje.
% IDEA: Para lograr esta tarea, solo habría que agregar los operadores, funciones y/o procedimientos correspondientes a la clase que se quiere incorporar, junto con la adición de los chequeos adecuados para los mismos.
Por dar un ejemplo, una alternativa sería agregar la clase \textbf{Num}; la cual representaría a cualquier conjunto de valores que admita las operaciones de suma, resta, multiplicación, y demás operaciones numéricas.
% IDEA: Sobre esta característica, una opción posible sería añadir la clase \textbf{Enum}.
% IDEA: La cual se emplearía para representar a todos los tipos que pueden ser enumerados desde su primer valor hasta el último.

Otra extensión del lenguaje es la posibilidad de definir instancias para los tipos declarados, donde ya existe una sintaxis pensada para estas construcciones.
Actualmente solo algunos tipos tienen definidas las instancias de \textbf{Eq} y \textbf{Ord} de forma nativa, donde no es posible definir nuevas instancias para los demás tipos.

\begin{lstlisting}[ style = lang, caption = Declaración de Instancia para Nodo, label = instanciaNodo ]
type node = tuple
              value : int,
              next  : pointer of node
            end tuple

inst Eq ( n1, n2 : node ) ret equal : bool
  equal := n1.value == n2.value && n1.next == n2.next
end inst

end type
\end{lstlisting}

% IDEA: Sobre como declarar una instancia para una clase determinada, en el lenguaje solo se ha definido una sintaxis provisoria en este aspecto.
En el fragmento~(\ref{instanciaNodo}) se ilustra un ejemplo particular, en el cual se declara la operación de comparación \lstinline[style = lang]{==} para el tipo \textit{nodo}.
De esta manera sería posible definir una instancia para la clase \lstinline[style = lang]{Eq} en el lenguaje.
Inicialmente al limitarnos a solo dos clases, que caracterizan propiedades similares, la verificación de sus instancias se simplifica.

\subsubsection{Estructuras Iterables}

Durante el desarrollo del lenguaje se analizó la posibilidad de incluir de manera nativa la clase \textbf{Iter} para caracterizar a todos los tipos que poseen la capacidad de ser iterados, es decir que pueden ser \textit{recorridos} de cierta forma obteniendo todos los elementos que los componen.
Algunos tipos que podrían tener instancias de la clase serían los conjuntos y las listas, donde ambos representan una colección de elementos.
% IDEA: ...donde se necesita declarar la respectiva implementación de cada una.
% IDEA: El primero formaría parte de esta clase de manera predefinida, mientras que el segundo necesita de su respectiva implementación.
Una vez que se define la instancia de la clase para un tipo en particular, se podrán utilizar valores del mismo dentro de la sentencia $\T{for} \; x \; \T{in} \; e \; \T{do} \; s_{1} \ldots s_{m}$, lo cual permite recorrerlos obteniendo uno por uno todos los elementos que lo conforman.
El siguiente ejemplo calcula la sumatoria de elementos de un conjunto, suponiendo que el tipo \lstinline[style = lang]{set} tiene instancia de \textbf{Iter}.
% IDEA: Un ejemplo posible se ilustra en el fragmento~(\ref{sumatoriaIter}), donde se calcula la sumatoria de elementos de un conjunto.

\begin{lstlisting}[ style = lang, caption = Sumatoria de Conjunto Iterable, label = sumatoriaIter ]
fun sumIter ( s : set of (int) ) ret sum : int
  sum := 0
  for i in s do
    sum := i + sum
  od
end fun
\end{lstlisting}

Es relevante aclarar que a pesar de referirnos a \textbf{Iter} como una clase, aún no se ha determinado si la misma será definida como tal en el lenguaje, donde es posible que durante el desarrollo del proyecto su naturaleza sea modificada por lo que su interpretación cambie de manera acorde.

\subsection{Respecto a la Implementación}

Existe ciertos aspectos de la implementación que no han sido desarrollados por completo, o más bien, podrían ser mejorados para ofrecer un lenguaje más sofisticado.

\subsubsection{Generación de Múltiples Errores}

Uno de los aspectos que se puede mejorar de la implementación del lenguaje, es la generación de múltiples errores tanto en la etapa del \textit{parser} como en la de \textit{chequeos estáticos}.
Actualmente cuando se encuentra un error durante el parsing o la verificación de un programa se aborta por completo el análisis del mismo, generando un mensaje de error sobre la causa de la falla.
Una característica deseable en el lenguaje, es poder capturar la mayor cantidad posible de errores encontrados en una determinada etapa, antes de fallar, y generar todos los mensajes necesarios correspondientes.
% IDEA: Esto obviamente beneficiaría al usuario, ya que se tendría que dedicar menor tiempo a la corrección de errores, agilizando efectivamente el uso de la herramienta, y podría destinar mayor atención al diseño de algoritmos.

\begin{itemize}

\item
\textbf{Parser}
La librería \Megaparsec{} ofrece un mecanismo para señalar múltiples errores en una sola corrida del parser.
Un requisito para utilizar esta funcionalidad es que debe ser posible omitir la sección problemática de la cadena de caracteres que estamos intentando parsear, para resumir el parseo en una posición que se considere estable.
% IDEA: ...donde comúnmente se generaría un error de parsing...
Lo cual se consigue con el uso de la función \lstinline[style = haskell]{withRecovery}, que permite continuar el parsing luego de ocurrido un error.

\iffalse
% Demasiados detalles...
Si quisiéramos aprovechar esta funcionalidad, deberíamos adaptar nuestro parser.
Debido que identificar cual puede ser un buen punto de recuperación es una tarea compleja, es necesario realizar algunas modificaciones al intérprete para poder facilitar la misma.
Un cambio conveniente posible, sería utilizar el punto y coma (\textbf{;}) para separar la secuencia de instrucciones del lenguaje.
De esta forma, al fallar el parser se podrían consumir \textit{tokens} hasta encontrar este delimitador, punto donde se puede recuperar y continuar el análisis normal del programa.
\fi

\item
\textbf{Chequeos Estáticos}
Una posibilidad para la generación de múltiples errores en esta etapa, está descripta en el artículo que se empleó como guía para la implementación de los chequeos estáticos~\cite{MonadicTC}.
Esta opción consiste en la implementación de un combinador, que es invocado cada vez que se deben verificar una serie de elementos sintácticos.
La idea es poder combinar la lista de chequeos a realizar y, si todos tienen éxito, se devuelven sus resultados correspondientes.
En caso contrario, se deberán acumular la totalidad de los errores producidos, y luego generar los mensajes informativos adecuados.

\iffalse
% Demasiados detalles...
Esta técnica \textit{ad hoc}, resulta ser la más simple, y requiere pocas modificaciones del código actual.
De todas formas no aprovecha al máximo la estructura en la que se organiza un programa, y puede no ser trivial cuando se debe aplicar el combinador, y cuando no.
Lo cual se debe a que muchas veces la corrección semántica de cierta construcción, depende de la validez de los elementos previos a los que la misma hace referencia.
\fi

\iffalse
% Demasiados detalles...
Otra opción, es rediseñar los chequeos estáticos actuales para realizar más de una recorrida al \textit{árbol de sintaxis abstracta}.
La idea es que en una primera pasada, se puedan analizar todos los prototipos de las definiciones de tipo, y las declaraciones de funciones y procedimientos del programa.
Una vez finalizado este análisis, se deberá realizar una segunda pasada donde esta vez se deberán verificar los cuerpos de las construcciones anteriormente mencionadas.
De esta manera, se pueden acumular la totalidad de errores encontrados en una de estas fases, antes de abortar el análisis del programa con un mensaje de error.
Comparada con la técnica anterior, la opción actual resulta mucha más compleja y necesita modificar gran parte de la implementación.
A pesar de esto, la misma aprovecha la idea que los prototipos son válidos de forma mutuamente independiente entre ellos, al igual que como ocurre con sus respectivos cuerpos.
Otra ventaja de la técnica actual sobre la opción anterior, es que la misma permitiría invocar funciones y procedimientos sin importar el lugar espacial donde hayan sido declaradas.
Incluso se admitiría la posibilidad de definir de forma mutua las construcciones previamente mencionadas.
\fi

\end{itemize}

\subsubsection{Coersiones y Subtipado}

En el lenguaje hay dos tipos numéricos, los valores enteros y los valores reales.
En ambos casos se encuentra definido un listado de operadores sobrecargados que pueden ser utilizados para operar con cualquiera de los valores previos.
Una restricción de la implementación actual, es que ambos tipos son percibidos como valores completamente diferentes.
Esto significa, por ejemplo, que la operación de sumar enteros con reales es detectada como un error de tipos.
% IDEA: Al mismo tiempo, la constante \textbf{inf} es interpretada como un valor entero, al igual como sucede con los tamaños polimórficos.
Esto imposibilita implementar ciertos algoritmos donde deseamos realizar operaciones donde se combinan ambos tipos de valores numéricos, como es el caso de querer calcular el promedio de un arreglo de números reales, el cual posee tamaño dinámico.
El código presentado a continuación~(\ref{promedioReal}) ilustra la situación mencionada.
Notar que al chequear la última asignación de la función, el lenguaje fallará debido a un error de tipos producido por la división de un número real por uno de tipo entero.

\iffalse
% Demasiados detalles...
Para flexibilizar el intérprete, podríamos implementar una \textit{coersión} implícita que convierta un número de tipo entero, a otro equivalente de tipo real, si fuese necesario.
De esta forma, obtendríamos la capacidad de emplear valores enteros en contextos donde se esperan números reales, como es el caso del ejemplo previo, donde deseamos dividir la sumatoria de valores en un arreglo de reales por su tamaño entero.
Otras situaciones que también se permitirían, comprenden la asignación de enteros a variables reales, o la llamada de funciones con parámetros del primer tipo cuando se esperaban del segundo.
Incluso podríamos ir un paso más adelante, y declarar a los números enteros como un \textit{subtipo} de los valores reales.
Esto implicaría una modificación estructural del actual sistema de tipos, donde deberíamos permitir situaciones más complejas que las contempladas anteriormente, como puede ser la de manipular un arreglo de enteros como si fuese un arreglo de reales.
La propiedad aún debe ser discutida y evaluada, ya que es necesario determinar su verdadera utilidad para el dictado de la materia.
\fi

\begin{lstlisting}[ style = lang, caption = Promedio en Arreglo de Reales, label = promedioReal ]
fun averageReal ( a : array [n] of real ) ret avg : real
  var sum : real
  sum := 0
  for i := 1 to n do
    sum := a[i] + sum
  od
  avg := sum / n { Type Error }
end fun
\end{lstlisting}

\subsubsection{Inferencia de Tipos}

El sistema de tipos que se encuentra actualmente implementado puede resultar básico a la hora de resolver ciertas cuestiones debido que solo es un primer prototipo.
En consecuencia a esto se presentan algunas limitaciones, donde el algoritmo de unificación no es lo suficientemente sofisticado para resolver el polimorfismo admitido por funciones y procedimientos.
Un ejemplo particular es la llamada de las construcciones mencionadas con la constante \textbf{null}.
% IDEA: ...la cual simboliza un puntero vacío.
Tomando como ejemplo la implementación de la función~(\ref{inferenciaNull}); la cual obtiene el elemento señalado por un puntero si el mismo no es nulo, o devuelve su segundo argumento en caso contrario.
Si aplicamos la función con la llamada \lstinline[style = lang]{pointerAccess(null, 5)}, entonces se producirá un error en la etapa de chequeos estáticos del lenguaje, debido a la imposibilidad de chequear los tipos involucrados.

\iffalse
% Demasiados detalles
Esto es debido que la constante \textbf{null} tiene tipo polimórfico, lo que significa que puede ser utilizada como un puntero a un entero, como también un puntero a un arreglo, o alguna otra estructura diferente.
Esta característica permite un sistema de tipos más flexible, lo que facilita el uso del intérprete; pero al mismo tiempo, imposibilita el chequeo de tipos cuando el \textit{algoritmo de unificación} necesita de información adicional para inferir un tipo particular en la llamada de una función o procedimiento.
\fi

\begin{lstlisting}[ style = lang, caption = Ejemplo para Inferencia de Tipos, label = inferenciaNull ]
fun pointerAccess ( p : pointer of T, t : T) ret value : T
  if p == null then
    value := t
  else
    value := #p
  fi
end fun
\end{lstlisting}

% IDEA: A causa de esta constante es necesario adaptar nuestra implementación para contemplar estas situaciones.
% IDEA: En otros contextos donde se puede emplear el valor \textbf{null}, el algoritmo de chequeo de tipos es capaz de resolver esta particularidad mediante el uso de técnicas \textit{ad hoc}.
El conflicto sucede cuando es necesario inferir un tipo para la constante \textbf{null}, combinada con el polimorfismo que admite una función o un procedimiento, debido que nuestro algoritmo de unificación no es lo suficientemente sofisticado para asignarle correctamente un tipo.
% IDEA: ...lo que nos fuerza a requerir una mayor cantidad de información contextual para realizar las validaciones correspondientes.

Para resolver este limitante, se presentan dos opciones que requieren la modificación de la implementación actual.
La primera, orientada al tipado explícito, implica la adaptación de la sintaxis del lenguaje para forzar al programador a anotar el tipo concreto que tendrá la constante en el momento que se utiliza.
% IDEA: De esta forma, durante la verificación se tendrá la suficiente cantidad de información para que el \textit{juicio de tipado} sea directo.
La segunda opción, orientada al tipado implícito, supone la implementación de un algoritmo de \textit{inferencia de tipos}.
Utilizando ideas del \textit{algoritmo Hindley-Milner}~\cite{Inferencia}, se podría adecuar nuestro sistema de tipos para lograr que el mismo sea capaz de inferir los tipos apropiados, sin necesidad de anotar el tipo de nuestra constante.

\iffalse
% Demasiados detalles...
La primera, orientada al tipado explícito, implica la adaptación de la sintaxis del lenguaje para forzar al usuario a anotar el tipo concreto que tendrá la constante en el momento que se utiliza.
De esta forma, durante la verificación se tendrá la suficiente cantidad de información para que el \textit{juicio de tipado} sea directo.
Como consecuencia de esta alternativa, el sistema de tipos se simplifica a costa de una sintaxis más verbosa.
Volviendo al ejemplo, si se efectuara la llamada \lstinline[style = lang]{accesoPuntero(null[int], 5)}, el \textit{algoritmo de unificación} sería capaz de verificar todas las propiedades necesarias de forma exitosa, y se continuaría con el análisis del programa.

La segunda opción, orientada al tipado implícito, supone la implementación de un algoritmo de \textit{inferencia de tipos}.
Extrayendo ideas del \textit{algoritmo Hindley-Milner}~\cite{Inferencia}, se podría adecuar nuestro sistema de tipos para lograr que el mismo sea capaz de inferir los \textit{juicios de tipado} apropiados, sin necesidad de anotar el tipo de nuestra constante.
El ejemplo previo permanecería sin cambios, sin embargo se necesitaría de una modificación estructural del algoritmo de \textit{type check} implementado.
De manera opuesta a la alternativa anterior, la sintaxis no se debería ajustar pero el sistema de tipos resultaría más complejo.
Una propiedad que se ganaría al elegir esta opción, es que se permitirían declarar otras clases de funciones como la del fragmento~(\ref{inferenciaLista}).
En la misma, se inicializa una lista de forma genérica, sin conocer el tipo de sus elementos.

\begin{lstlisting}[ style = lang, caption = Inicialización de Lista con Inferencia de Tipos, label = inferenciaLista ]
fun inicializarLista ( ) ret lista : lista of (T)
  lista := null
end fun
\end{lstlisting}
\fi

% Versión Previa
\iffalse

% Síntesis del Intérprete
\iffalse
\subsection{Continuando el Desarrollo}

Hasta ahora, solo hemos trabajado en la etapa de \textit{análisis} del intérprete.
Partiendo de un archivo de texto, somos capaces de obtener la estructura sintáctica de un programa, y verificar de forma \textit{estática} las distintas propiedades semánticas requeridas por el lenguaje.
Pero ahora debemos pasar a una nueva etapa, la fase de \textit{síntesis}.
Utilizando la representación intermedia obtenida previamente, queremos tener la capacidad de realizar una ejecución del código provisto, y durante la misma, también poder validar de forma \textit{dinámica} ciertas condiciones necesarias para asegurar el correcto funcionamiento del programa.
Sumado a todo esto, es indispensable diseñar un medio de interacción para que el programador pueda comunicarse con nuestro intérprete.
El desarrollo de una \textit{interfaz de usuario} es otro aspecto fundamental para la implementación del programa, y su posterior aplicación en el dictado de la asignatura.

\subsubsection{Síntesis}

La etapa de \textit{síntesis} comprende todos los aspectos \textit{dinámicos} sobre la interpretación de un programa.
Comenzando con el \textit{árbol de sintaxis abstracta} obtenido durante el \textit{análisis} del código, debemos simular la ejecución del programa en base a los datos de entrada provistos por el usuario.
Para poder realizar esta acción, necesitaremos definir formalmente la semántica \textit{small step} del lenguaje; la cual facilitará los medios necesarios para examinar detalles particulares sobre el orden de evaluación de las distintas construcciones especificadas en el código.
Esto nos permitirá efectuar una por una las instrucciones del programa, al mismo tiempo que se exhiben los estados intermedios obtenidos durante su computación.

Sumado a lo anterior, durante la ejecución del código, es necesario llevar a cabo la validación \textit{dinámica} del mismo.
Debido que la totalidad de errores de un programa no puede ser detectada de forma \textit{estática}, hay ciertas verificaciones que son realizadas durante esta etapa.
Las mismas consistirán en su mayoría de asegurar el uso adecuado de memoria por parte del usuario.
Ya sea para liberar o reservar memoria mediante el empleo de punteros, o incluso el acceso a ciertas ubicaciones de memoria representadas por variables, es fundamental asegurar que la ejecución del programa se pueda realizar de forma consistente, y que no se presenten comportamientos inesperados durante la misma.

\subsubsection{Interfaz de Usuario}

Uno de los motivos por el que se inició el desarrollo del intérprete, fue para facilitar el estudio de los contenidos presentados en la materia \Materia{}.
Debido que los usuarios finales de nuestro programa serán, en su mayoría, estudiantes que se están introduciendo en el ámbito de la implementación de algoritmos, es importante proveer una \textit{interfaz de usuario} intuitiva y amigable para el uso del intérprete.
Actualmente, no hay ningún aspecto completamente definido sobre el futuro diseño de la interfaz, sino más bien, se están valorando distintas alternativas y funcionalidades particulares para su próxima implementación.

En la versión presente del intérprete, solo se cuenta con una interfaz básica por línea de comando, la cual se asemeja más a una herramienta para la verificación del código implementado del programa que a un mecanismo para interactuar propiamente con el intérprete.
Una de las opciones consideradas, es la creación de una interfaz gráfica de usuario la cual permita observar la evolución del estado de las variables del programa a medida que se avanza en su ejecución.
También se analiza la posibilidad de utilizar una codificación de colores para resaltar los errores encontrados durante la interpretación del código.
Obviamente, se proveería un editor de texto dentro del programa para facilitar esta característica.
Incluso se discutió adicionar soporte web a la herramienta, lo que permitiría utilizar el intérprete desde el navegador.
\fi

\subsection{Generación de Múltiples Errores}

Uno de los aspectos que se puede mejorar de la implementación del lenguaje, es la generación de múltiples errores tanto en la etapa del \textit{parser} como en la de \textit{chequeos estáticos}.
Actualmente cuando se encuentra un error durante el parsing o la verificación de un programa se aborta por completo el análisis del mismo, generando un mensaje de error informativo sobre la causa de la falla.
Una característica deseable en el lenguaje, es poder capturar la mayor cantidad posible de errores encontrados en una determinada etapa, antes de fallar, y generar todos los mensajes necesarios correspondientes.
Esto obviamente beneficiaría al usuario, ya que se tendría que dedicar menor tiempo a la corrección de errores, agilizando efectivamente el uso de la herramienta, y podría destinar mayor atención al diseño de algoritmos.

\subsubsection{Parser}

La librería \Megaparsec{} ofrece un mecanismo para señalar múltiples errores en una sola corrida del parser.
Un requisito para poder utilizar esta funcionalidad es que debe ser posible omitir una sección problemática de la entrada, donde comúnmente se generaría un error de parsing, y resumir el análisis en una posición que se considere estable.
Lo cual se consigue con el uso de la función \lstinline[style = haskell]{withRecovery}, que permite continuar el parsing luego de ocurrido un error.

\iffalse
% Demasiados detalles...
Si quisiéramos aprovechar esta funcionalidad, deberíamos adaptar nuestro parser.
Debido que identificar cual puede ser un buen punto de recuperación es una tarea compleja, es necesario realizar algunas modificaciones al intérprete para poder facilitar la misma.
Un cambio conveniente posible, sería utilizar el punto y coma (\textbf{;}) para separar la secuencia de instrucciones del lenguaje.
De esta forma, al fallar el parser se podrían consumir \textit{tokens} hasta encontrar este delimitador, punto donde se puede recuperar y continuar el análisis normal del programa.
\fi

\subsubsection{Chequeos Estáticos}

Una posibilidad para la generación de múltiples errores en esta etapa, está descripta en el artículo que se empleó como guía para la implementación de los chequeos estáticos del lenguaje~\cite{MonadicTC}.
Esta opción consiste en la implementación de un combinador, que es invocado cada vez que se deben verificar una serie de elementos sintácticos.
La idea es poder combinar la lista de chequeos a realizar y, si todos tienen éxito, se devuelven sus resultados correspondientes.
En caso contrario, se deberán acumular la totalidad de los errores producidos, y luego generar los mensajes informativos adecuados.
Esta técnica \textit{ad hoc}, resulta ser la más simple, y requiere pocas modificaciones del código actual.
De todas formas no aprovecha al máximo la estructura en la que se organiza un programa, y puede no ser trivial cuando se debe aplicar el combinador, y cuando no.
Lo cual se debe a que muchas veces la corrección semántica de cierta construcción, depende de la validez de los elementos previos a los que la misma hace referencia.

\iffalse
% Demasiados detalles...
Otra opción, es rediseñar los chequeos estáticos actuales para realizar más de una recorrida al \textit{árbol de sintaxis abstracta}.
La idea es que en una primera pasada, se puedan analizar todos los prototipos de las definiciones de tipo, y las declaraciones de funciones y procedimientos del programa.
Una vez finalizado este análisis, se deberá realizar una segunda pasada donde esta vez se deberán verificar los cuerpos de las construcciones anteriormente mencionadas.
De esta manera, se pueden acumular la totalidad de errores encontrados en una de estas fases, antes de abortar el análisis del programa con un mensaje de error.
Comparada con la técnica anterior, la opción actual resulta mucha más compleja y necesita modificar gran parte de la implementación.
A pesar de esto, la misma aprovecha la idea que los prototipos son válidos de forma mutuamente independiente entre ellos, al igual que como ocurre con sus respectivos cuerpos.
Otra ventaja de la técnica actual sobre la opción anterior, es que la misma permitiría invocar funciones y procedimientos sin importar el lugar espacial donde hayan sido declaradas.
Incluso se admitiría la posibilidad de definir de forma mutua las construcciones previamente mencionadas.
\fi

\subsection{Enriquecer el Lenguaje}

Existen una serie de funcionalidades que fueron consideradas a lo largo del desarrollo de este trabajo, pero que no llegaron a ser incluidas en esta primera versión del lenguaje.
Las mismas fueron relegadas por diversos motivos a medida que se avanzó en el refinamiento de la idea original.
% IDEA: Algunas debieron ser omitidas por falta de tiempo, otras a causa de no poder llegar a un concenso en su diseño, e incluso algunas por las dificultades encontradas durante su implementación.
A continuación daremos una breve descripción de cada una de estas, junto con sugerencias para facilitar su futura incorporación al lenguaje.

\subsubsection{Soporte para Múltiples Módulos}

Nuestro lenguaje solo permite definir programas en un único contexto.
% IDEA: Esto puede no ser un limitante en el poder expresivo del lenguaje, pero si...
Lo cual resulta un inconveniente para su incorporación en el dictado de la materia.
Debido que durante la asignatura se hace hincapié en la importancia de la separación de los módulos para la especificación de \textit{tipos abstracto de datos}, y los correspondientes a su implementación, es fundamental que el lenguaje provea las herramientas necesarias para mantener esa abstracción mediante el encapsulamiento de las construcciones involucradas.

Para incorporar esta funcionalidad, se deberá determinar la sintaxis adecuada para poder importar y exportar tipos, funciones, y procedimientos definidos dentro de un determinado módulo.
Sumado a esto, se tendrán que adaptar los chequeos estáticos para soportar estas nuevas situaciones.
En particular los sinónimos de tipos actualmente son interpretados como una definición transparente, donde idealmente quisiéramos que su definición se vuelva opaca fuera del módulo en el que fueron declarados.
Respecto a la implementación, se deberá adaptar la información de posición \lstinline[style = haskell]{Info} para almacenar además, el nombre del archivo \lstinline[style = haskell]{File} correspondiente a la ocurrencia del elemento sintáctico analizado.
% IDEA: ...similar a como lo hace \Haskell{} cuando se declaran con \lstinline[style = haskell]{type}.
% IDEA: ...o incluso reproducir un comportamiento parecido a \lstinline[style = haskell]{newtype} en \Haskell{}; lo cual también permitiría declarar nuevas instancias de clase para el tipo aludido.

\subsubsection{Coersiones y Subtipado}

En el lenguaje hay dos tipos numéricos, los valores enteros y los valores reales.
En ambos casos se encuentra definido un listado de operadores sobrecargados que pueden ser utilizados para operar con cualquiera de los valores previos.
Una restricción de la implementación actual, es que ambos tipos son percibidos como valores completamente diferentes.
Esto significa, por ejemplo, que la operación de sumar enteros con reales es detectada como un error de tipos.
% IDEA: Al mismo tiempo, la constante \textbf{inf} es interpretada como un valor entero, al igual como sucede con los tamaños polimórficos.
Esto imposibilita especificar ciertos algoritmos donde deseamos realizar operaciones donde se combinan ambos tipos de valores numéricos, como es el caso de querer calcular el promedio de un arreglo de números reales, el cual posee tamaño dinámico.
El código presentado~(\ref{promedioReal}) ilustra esta situación mencionada.
Notar que al analizar la última asignación de la función, el lenguaje fallará debido a un error de tipos producido por la división de un número real por uno de tipo entero.

\iffalse
% Demasiados detalles...
Para flexibilizar el intérprete, podríamos implementar una \textit{coersión} implícita que convierta un número de tipo entero, a otro equivalente de tipo real, si fuese necesario.
De esta forma, obtendríamos la capacidad de emplear valores enteros en contextos donde se esperan números reales, como es el caso del ejemplo previo, donde deseamos dividir la sumatoria de valores en un arreglo de reales por su tamaño entero.
Otras situaciones que también se permitirían, comprenden la asignación de enteros a variables reales, o la llamada de funciones con parámetros del primer tipo cuando se esperaban del segundo.
Incluso podríamos ir un paso más adelante, y declarar a los números enteros como un \textit{subtipo} de los valores reales.
Esto implicaría una modificación estructural del actual sistema de tipos, donde deberíamos permitir situaciones más complejas que las contempladas anteriormente, como puede ser la de manipular un arreglo de enteros como si fuese un arreglo de reales.
La propiedad aún debe ser discutida y evaluada, ya que es necesario determinar su verdadera utilidad para el dictado de la materia.
\fi

\begin{lstlisting}[ style = lang, caption = Promedio en Arreglo de Reales, label = promedioReal ]
fun averageReal ( a : array [n] of real ) ret avg : real
  var sum : real
  sum := 0
  for i := 1 to n do
    sum := a[i] + sum
  od
  avg := sum / n { Type Error }
end fun
\end{lstlisting}

\subsubsection{Estructuras Iterables}

Durante el desarrollo del lenguaje, se analizó la posibilidad de incluir la clase \textbf{Iter} para caracterizar a todas las construcciones que posean la capacidad de ser iteradas.
Ejemplos de instancias podrían ser los conjuntos y las listas, donde se necesita declarar la respectiva implementación de cada una.
% IDEA: El primero formaría parte de esta clase de manera predefinida, mientras que el segundo necesita de su respectiva implementación.
Estas estructuras representan una serie de elementos con algún orden determinado.
Una vez que el usuario define la instancia correspondiente a la clase, para un tipo en particular, se podrán utilizar valores del mismo dentro de la instrucción $\T{for} \; x \; \T{in} \; e \; \T{do} \; s_{1} \ldots s_{m}$, lo cual permitiría recorrer estas construcciones, e ir obteniendo uno por uno todos los elementos que las conforman.
Un ejemplo posible se ilustra en el fragmento~(\ref{sumatoriaIter}), donde se calcula la sumatoria de elementos de un arreglo.

\begin{lstlisting}[ style = lang, caption = Sumatoria de Conjunto Iterable, label = sumatoriaIter ]
fun sumIter ( s : set of (int) ) ret sum : int
  sum := 0
  for i in s do
    sum := i + sum
  od
end fun
\end{lstlisting}

\iffalse
% Demasiados detalles...
Se estudiaron los mecanismos que lenguajes como \Python{} y \Java{} emplean para crear objetos iterables.
En base a esto, se discutieron distintas maneras para declarar instancias de la clase en nuestro lenguaje.
Una alternativa considerada, consistía en definir tres métodos para la estructura iterable.
El primero, inicializaba un cursor para referenciar al primer elemento de la construcción.
El segundo, verificaba si existía un sucesor en base al puntero actual.
Y finalmente, el tercero obtenía el siguiente elemento, desplazando el cursor hacia adelante.
Debido que la declaración de estructuras iterables no se adecuaba a la manera utilizada para definir instancias en el lenguaje, se decidió aplazar el diseño de esta funcionalidad para la siguiente etapa de desarrollo del intérprete.
\fi

\subsubsection{Clases e Instancias}

Actualmente en el lenguaje solo hay definidas dos clases de tipo, \textbf{Eq} y \textbf{Ord}.
Las cuales representan a los tipos que permiten comparaciones entre sus valores, ya sea en base a su igualdad en el caso de la primera, o según su orden para la segunda.
Una posible expansión del lenguaje sería el agregado de nuevas clases de tipo.
% IDEA: Hay una posibilidad que en un futuro resulte útil añadir nuevas clases al lenguaje.
% IDEA: Para lograr esta tarea, solo habría que agregar los operadores, funciones y/o procedimientos correspondientes a la clase que se quiere incorporar, junto con la adición de los chequeos adecuados para los mismos.
Por dar un ejemplo ilustrativo, una alternativa sería adicionar la clase \textbf{Num}; la cual representaría a cualquier conjunto de valores que admita las operaciones de suma, resta, multiplicación, y demás operaciones numéricas.
% IDEA: Sobre esta característica, una opción posible sería añadir la clase \textbf{Enum}.
% IDEA: La cual se emplearía para representar a todos los tipos que pueden ser enumerados desde su primer valor hasta el último.

\begin{lstlisting}[ style = lang, caption = Declaración de Instancia para Nodo, label = instanciaNodo ]
type node = tuple
              value : int,
              next  : pointer of node
            end tuple

inst Eq ( n1, n2 : node ) ret equal : bool
  equal := n1.value == n2.value && n1.next == n2.next
end inst

end type
\end{lstlisting}

% IDEA: Sobre como declarar una instancia para una clase determinada, en el lenguaje solo se ha definido una sintaxis provisoria en este aspecto.
En el fragmento~(\ref{instanciaNodo}) se ilustra un ejemplo particular, en el cual se especifica la operación de igualdad para el tipo \textit{nodo}.
De esta manera sería posible definir una instancia para la clase \lstinline[style = lang]{Eq} en el lenguaje.
Inicialmente al limitarnos a solo dos clases, que caracterizan propiedades similares, la verificación de sus instancias se simplifica.

\iffalse
% Demasiados detalles...
A continuación, describimos informalmente las validaciones que se deberían efectuar para asegurar que una definición de instancia es correcta.

\begin{enumerate}
    \item Para todo tipo definido, existe una única instancia para una determinada clase.
    Similar a \Haskell{}, se pueden emplear tipos concretos, o agregar restricciones de clase a las variables de tipo, en las declaraciones de instancias para tipos parametrizados.
    \item Las instancias solo pueden tomar dos argumentos, y deben ser del mismo tipo.
    En particular, la definición del tipo y sus declaraciones de instancias deben ir juntas.
    Esta verificación es propia de las únicas dos clases del lenguaje.
    \item El retorno de una instancia debe ser un valor booleano.
    Esta propiedad, al igual que la anterior, es específica de las clases mencionadas previamente.
    \item El cuerpo de la declaración de instancias deberá cumplir las mismas verificaciones que satisface el cuerpo de una función.
    Esto se debería mantener incluso para las validaciones realizadas durante el tiempo de ejecución.
\end{enumerate}
\fi

\iffalse
% Demasiados detalles...
Un último detalle importante a mencionar, es que la declaración de instancias se permite solamente para las estructuras de tipo tupla.
Esto es debido que un tipo enumerado satisface ambas clases de forma natural.
Mientras que un sinónimo de tipo, hereda todas las clases que implementa el tipo de su definición.
Si en un futuro se adoptará otro juicio, la modificación de la implementación actual es sencilla.
\fi

\subsubsection{Inferencia de Tipos}

El sistema de tipos que se encuentra actualmente implementado puede resultar básico a la hora de resolver ciertas cuestiones, debido que solo es un primer prototipo para el lenguaje.
Debido a esto se presentan algunas limitaciones cuando se utiliza el mismo.
Un ejemplo particular, es la llamada de funciones y procedimientos con la constante \textbf{null}.
% IDEA: ...la cual simboliza un puntero vacío.
Tomando como ejemplo la implementación de la función~(\ref{inferenciaNull}); la cual obtiene el elemento señalado por un puntero si el mismo no es nulo, o devuelve su segundo argumento en caso contrario.
Si aplicamos la función con la llamada \lstinline[style = lang]{pointerAccess(null, 5)}, entonces se generaría un error en la etapa de chequeos estáticos del lenguaje, debido a la imposibilidad de chequear los tipos involucrados.

\iffalse
% Demasiados detalles
Esto es debido que la constante \textbf{null} tiene tipo polimórfico, lo que significa que puede ser utilizada como un puntero a un entero, como también un puntero a un arreglo, o alguna otra estructura diferente.
Esta característica permite un sistema de tipos más flexible, lo que facilita el uso del intérprete; pero al mismo tiempo, imposibilita el chequeo de tipos cuando el \textit{algoritmo de unificación} necesita de información adicional para inferir un tipo particular en la llamada de una función o procedimiento.
\fi

\begin{lstlisting}[ style = lang, caption = Ejemplo para Inferencia de Tipos, label = inferenciaNull ]
fun pointerAccess ( p : pointer of T, t : T) ret value : T
  if p == null then
    value := t
  else
    value := #p
  fi
end fun
\end{lstlisting}

Debido a esta constante es necesario adaptar nuestra implementación para contemplar estas situaciones.
En otros contextos donde se puede emplear el valor \textbf{null}, el algoritmo de \textit{type check} es capaz de resolver esta particularidad mediante el uso de técnicas \textit{ad hoc}.
El conflicto sucede cuando es necesario realizar algún tipo de inferencia para la constante, combinada con el polimorfismo paramétrico que admite una función o un procedimiento, debido que nuestro algoritmo de unificación no es lo suficientemente sofisticado para asignarle correctamente un tipo.
% IDEA: ...lo que nos fuerza a requerir una mayor cantidad de información contextual para realizar las validaciones correspondientes.

Para resolver este limitante, se presentan dos opciones que requieren la modificación de la implementación actual.
La primera, orientada al tipado explícito, implica la adaptación de la sintaxis del lenguaje para forzar al usuario a anotar el tipo concreto que tendrá la constante en el momento que se utiliza.
De esta forma, durante la verificación se tendrá la suficiente cantidad de información para que el \textit{juicio de tipado} sea directo.
La segunda opción, orientada al tipado implícito, supone la implementación de un algoritmo de \textit{inferencia de tipos}.
Extrayendo ideas del \textit{algoritmo Hindley-Milner}~\cite{Inferencia}, se podría adecuar nuestro sistema de tipos para lograr que el mismo sea capaz de inferir los \textit{juicios de tipado} apropiados, sin necesidad de anotar el tipo de nuestra constante.

\iffalse
% Demasiados detalles...
La primera, orientada al tipado explícito, implica la adaptación de la sintaxis del lenguaje para forzar al usuario a anotar el tipo concreto que tendrá la constante en el momento que se utiliza.
De esta forma, durante la verificación se tendrá la suficiente cantidad de información para que el \textit{juicio de tipado} sea directo.
Como consecuencia de esta alternativa, el sistema de tipos se simplifica a costa de una sintaxis más verbosa.
Volviendo al ejemplo, si se efectuara la llamada \lstinline[style = lang]{accesoPuntero(null[int], 5)}, el \textit{algoritmo de unificación} sería capaz de verificar todas las propiedades necesarias de forma exitosa, y se continuaría con el análisis del programa.

La segunda opción, orientada al tipado implícito, supone la implementación de un algoritmo de \textit{inferencia de tipos}.
Extrayendo ideas del \textit{algoritmo Hindley-Milner}~\cite{Inferencia}, se podría adecuar nuestro sistema de tipos para lograr que el mismo sea capaz de inferir los \textit{juicios de tipado} apropiados, sin necesidad de anotar el tipo de nuestra constante.
El ejemplo previo permanecería sin cambios, sin embargo se necesitaría de una modificación estructural del algoritmo de \textit{type check} implementado.
De manera opuesta a la alternativa anterior, la sintaxis no se debería ajustar pero el sistema de tipos resultaría más complejo.
Una propiedad que se ganaría al elegir esta opción, es que se permitirían declarar otras clases de funciones como la del fragmento~(\ref{inferenciaLista}).
En la misma, se inicializa una lista de forma genérica, sin conocer el tipo de sus elementos.

\begin{lstlisting}[ style = lang, caption = Inicialización de Lista con Inferencia de Tipos, label = inferenciaLista ]
fun inicializarLista ( ) ret lista : lista of (T)
  lista := null
end fun
\end{lstlisting}
\fi

\fi

\iffalse

% \subsection{Múltiples Módulos}
% \subsection{Implementación de Estructuras Iterables}
% \subsection{Agregado de Clases Adicionales}
% \subsection{Refinamiento en Implementación de Instancias}
% \subsection{Inferencia de Tipos}
% \subsubsection{Llamada de F/P con Null}

Este concepto permitiría deducir el tipo de la constante, sin necesidad de modificar la sintaxis del lenguaje pero complicando el chequeo de tipos del intérprete.
\fi

\iffalse
\subsection{Forzar Indentación}
\subsection{Phantom Types}
\fi