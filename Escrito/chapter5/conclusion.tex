% Conclusión
En este trabajo final hemos definido formalmente e implementado un nuevo lenguaje.
Se han descripto las motivaciones principales que justificaron su creación, y se hizo mención de los elementos más relevantes que lo definen.
% IDEA: Junto a esto, con una serie de ejemplos sobre casos de uso y explicaciones informales, se han expuesto las diversas construcciones que ofrece el lenguaje.
Desde un punto de vista formal, las contribuciones de la tesis se pueden resumir en:

\begin{itemize}
\item
La definición informal de las características deseables para una primera versión del lenguaje.
% IDEA: La formalización de una primera versión para un lenguaje de programación que podrá ser utilizada en la formación de estudiantes en la carrera.
Se estudiaron de manera exhaustiva los ejemplos del pseudocódigo de la materia, donde se hizo un resumen con todas las construcciones empleadas en el mismo, con lo que se obtuvo una primera noción de un lenguaje con muchas características interesantes.
Algunas de las cuales son el polimorfismo paramétrico y \textit{ad hoc}, la posibilidad de emplear distintos tipos de valores para delimitar los índices válidos de arreglos, la capacidad de declarar instancias de clases, y la definición de estructuras iterables.
% IDEA: Algunas de las cuales son la inclusión de tipos como los \textit{conjuntos} y las \textit{listas}, la posibilidad de emplear distintos tipos de valores para delimitar los índices válidos de arreglos, y la declaración de estructuras iterables.
% IDEA: ...de un lenguaje demasiado complejo.
% IDEA: A través de la formalización se fue refinando en un lenguaje manejable, que resultara práctico para el uso de la asignatura.
% IDEA: Abarcativo / Amplio
% IDEA: Partiendo de una definición incompleta e imprecisa de un pseudocódigo, se logró diseñar un lenguaje inspirado en el mismo.
\item
La definición de su sintaxis, abstracta y concreta, lo cual permite establecer de manera precisa la forma de escribir programas en el lenguaje.
A través de las gramáticas correspondientes, logramos eliminar las ambigüedades presentes en determinadas estructuras sintácticas del pseudocódigo.
% IDEA: De alguna manera esta etapa fue un primer lugar donde se empezó a recortar la idea original del lenguaje que se había pensado luego de estudiar en profundidad el pseudocódigo.
% IDEA: De alguna manera esta etapa representó otra instancia para delimitar el alcance deseado de nuestro lenguaje.
% IDEA: Eliminar las ambigüedades del lenguaje que surgían durante el desarrollo de la asignatura.
\item
La definición de los chequeos estáticos, que determinan cuando un programa está bien tipado antes de su ejecución.
Para el caso del chequeo de tipos, se definen varias clases de \textit{juicios de tipado} con sus respectivas reglas.
% IDEA: ...se definieron formalmente los chequeos a efectuar de manera estática.
Los chequeos no solo se limitan a verificaciones de tipo, también se analiza el uso adecuado de variables donde se evita la lectura o escritura de variables que no soportan las respectivas acciones.
% IDEA: ...han sido declaradas para estas acciones.
% IDEA: ...con estos fines.
% IDEA: ...donde se evita la escritura de variables de lectura y la lectura de variables de escritura.
% IDEA: ...la declaración de funciones y procedimientos previo a su llamado, la unicidad de los identificadores para nombrar construcciones del lenguaje, entre otras.
% IDEA: En definitiva hemos definido \textit{juicios} para verificar de manera estática todas las propiedades necesarias que debe satisfacer un programa, donde también se han definido contextos adecuados para almacenar la información recopilada durante su análisis.
% IDEA: Definiendo \textit{juicios de tipado} con sus respectivas reglas se definieron formalmente los chequeos a efectuar.
\end{itemize}

Sumado al desarrollo matemático, realizamos la primer iteración en la implementación del lenguaje; donde utilizando la formalización como base, se han implementado las correspondientes etapas de \textit{parser} y \textit{chequeos estáticos}.
Respecto a la implementación, las contribuciones del trabajo son:

\begin{itemize}
\item
La implementación de las fases de \textit{análisis léxico} y \textit{análisis sintáctico}.
% IDEA: ...las cuales fueron desarrolladas de manera simultánea.
Los principales desafíos fueron adecuar la librería \Parsec{} a las necesidades de la implementación, y la posterior transición a la librería \Megaparsec{}.
Se estudiaron distintas opciones para la implementación de la sintaxis, la cual finalmente se adaptó al tipo de datos \lstinline[style = haskell]{Located}.
Permitiendo de esta manera almacenar la información de posición de todas las construcciones sintácticas relevantes, y facilitar la generación de mensajes de error precisos.
% IDEA: Se adaptó la sintaxis de manera de poder almacenar la información de posición en todas las construcciones sintácticas relevantes, lo cual permite la generación de mensajes de error precisos.
\item
La implementación de los chequeos estáticos, que comprenden las verificaciones estáticas que se realizan previa la ejecución de un programa.
% IDEA: Utilizando la definición formal como base...
Utilizando como guía el trabajo~\cite{MonadicTC}, y la formalización de los \textit{juicios de tipado}, se desarrolló una primera implementación incompleta del lenguaje.
La transición del formalismo a la implementación fue casi directa, salvo por las dificultades encontradas en el algoritmo de \textit{unificación} para inferir tipos, y el subtipado para los tipos numéricos.
% IDEA: La transición del formalismo a la implementación fue casi directa, salvo por las dificultades para diferenciar clases de identificadores, el agregado de mensajes de advertencia, y la complejidad del algoritmo de unificación para inferir tipos en determinados contextos.
% IDEA: ...y la manipulación de información de posición al generar un error estático.
% IDEA: Se emplea el mismo identificador para tamaños dinámicos y variables. (Identificadores)
% IDEA: Se debieron agregar verificaciones adicionales. (Advertencias)
% IDEA: Invariantes...
% IDEA: Se debieron adaptar los \textit{juicios de tipado} formalizados al código del proyecto, ...
\end{itemize}

\section{Trabajos Futuros}

El diseño del lenguaje aún está lejos de estar terminado, ya que este trabajo solo comprendió la primer etapa de su desarrollo.
Una importante tarea a realizar será definir matemáticamente la semántica dinámica que nos permita ejecutar programas; probablemente utilizando una semántica operacional \textit{small step} para poder ejecutar paso a paso un programa.
% IDEA: Por lo tanto, a continuación describiremos distintas tareas para realizar a futuro, con el fin de cumplir nuestro objetivo.
% IDEA: Algunas tareas para realizar a futuro estarán destinadas a completar la formalización restante del lenguaje, siguiendo con las fases posteriores necesarias para su definición; mientras otras podrán ser realizadas con la finalidad de mejorar y expandir sus funcionalidades actuales.

\subsection{Enriquecer el Lenguaje}

Existen una serie de características que fueron consideradas a lo largo del desarrollo de este trabajo, pero que no llegaron a ser incluidas en esta primera versión del lenguaje.
% IDEA: Las mismas fueron relegadas por diversos motivos a medida que se avanzó en el refinamiento de la idea original.
% IDEA: Algunas debieron ser omitidas por falta de tiempo, otras a causa de no poder llegar a un concenso en su diseño, e incluso algunas por las dificultades encontradas durante su implementación.
A continuación daremos una breve descripción de cada una de estas, junto con sugerencias para facilitar su futura incorporación.

\subsubsection{Soporte para Múltiples Módulos}

Nuestro lenguaje solo permite definir programas en un único contexto.
% IDEA: Esto puede no ser un limitante en el poder expresivo del lenguaje, pero si...
Lo cual resulta un inconveniente para su incorporación en el dictado de la materia.
Debido que durante la asignatura se hace hincapié en la importancia de la separación de los módulos para la especificación de \textit{tipos abstractos de datos}, y los correspondientes a su implementación, es fundamental que el lenguaje provea las herramientas necesarias para mantener esa abstracción mediante el encapsulamiento de las construcciones involucradas.

Para incorporar esta funcionalidad, se deberá determinar la sintaxis adecuada para poder importar y exportar tipos, funciones, y procedimientos definidos dentro de un determinado módulo.
Sumado a esto, se tendrán que adaptar los chequeos estáticos para soportar estas nuevas situaciones.
En particular los sinónimos de tipos actualmente son interpretados como una definición transparente, donde idealmente quisiéramos que su definición se vuelva opaca fuera del módulo en el que fueron declarados.
Respecto a la implementación, se deberá adaptar la información de posición \lstinline[style = haskell]{Info} para almacenar además, el nombre del archivo \lstinline[style = haskell]{File} correspondiente a la ocurrencia del elemento sintáctico analizado.
% IDEA: ...similar a como lo hace \Haskell{} cuando se declaran con \lstinline[style = haskell]{type}.
% IDEA: ...o incluso reproducir un comportamiento parecido a \lstinline[style = haskell]{newtype} en \Haskell{}; lo cual también permitiría declarar nuevas instancias de clase para el tipo aludido.

\subsubsection{Clases e Instancias}

Actualmente en el lenguaje solo hay definidas dos clases, \textbf{Eq} y \textbf{Ord}.
Las cuales representan a los tipos que permiten comparaciones entre sus valores, ya sea en base a su igualdad en el caso de la primera, o según su orden para la segunda.
Una posible expansión del lenguaje sería el agregado de nuevas clases nativas.
% IDEA: Hay una posibilidad que en un futuro resulte útil añadir nuevas clases al lenguaje.
% IDEA: Para lograr esta tarea, solo habría que agregar los operadores, funciones y/o procedimientos correspondientes a la clase que se quiere incorporar, junto con la adición de los chequeos adecuados para los mismos.
Por dar un ejemplo, una alternativa sería agregar la clase \textbf{Num}; la cual representaría a cualquier conjunto de valores que admita las operaciones de suma, resta, multiplicación, y demás operaciones numéricas.
% IDEA: Sobre esta característica, una opción posible sería añadir la clase \textbf{Enum}.
% IDEA: La cual se emplearía para representar a todos los tipos que pueden ser enumerados desde su primer valor hasta el último.

Otra extensión del lenguaje es la posibilidad de definir instancias para los tipos declarados, donde ya existe una sintaxis pensada para estas construcciones.
Actualmente solo algunos tipos tienen definidas las instancias de \textbf{Eq} y \textbf{Ord} de forma nativa, donde no es posible definir nuevas instancias para los demás tipos.

\begin{lstlisting}[ style = lang, caption = Declaración de Instancia para Nodo, label = instanciaNodo ]
type node = tuple
            value : int,
            next  : pointer of node
            end tuple

inst Eq ( n1, n2 : node ) ret equal : bool
  equal := n1.value == n2.value && n1.next == n2.next
end inst

end type
\end{lstlisting}

% IDEA: Sobre como declarar una instancia para una clase determinada, en el lenguaje solo se ha definido una sintaxis provisoria en este aspecto.
En el fragmento~(\ref{instanciaNodo}) se ilustra un ejemplo particular, en el cual se declara la operación de comparación \lstinline[style = lang]{==} para el tipo \textit{node}.
De esta manera sería posible definir una instancia para la clase \lstinline[style = lang]{Eq} en el lenguaje.
Inicialmente al limitarnos a solo dos clases, que caracterizan propiedades similares, la verificación de sus instancias se simplifica.

\subsubsection{Estructuras Iterables}

Durante el desarrollo del lenguaje se analizó la posibilidad de incluir de manera nativa la clase \textbf{Iter} para caracterizar a todos los tipos que poseen la capacidad de ser iterados, es decir que pueden ser \textit{recorridos} de cierta forma obteniendo todos los elementos que los componen.
Algunos tipos que podrían tener instancias de la clase serían los conjuntos y las listas, donde ambos representan una colección de elementos.
% IDEA: ...donde se necesita declarar la respectiva implementación de cada una.
% IDEA: El primero formaría parte de esta clase de manera predefinida, mientras que el segundo necesita de su respectiva implementación.
Una vez que se define la instancia de la clase para un tipo en particular, se podrán utilizar valores del mismo dentro de la sentencia $\T{for} \; x \; \T{in} \; e \; \T{do} \; s_{1} \ldots s_{m}$, lo cual permite recorrerlos obteniendo uno por uno todos los elementos que lo conforman.
El siguiente ejemplo calcula la sumatoria de elementos de un conjunto, suponiendo que el tipo \lstinline[style = lang]{set} tiene instancia de \textbf{Iter}.
% IDEA: Un ejemplo posible se ilustra en el fragmento~(\ref{sumatoriaIter}), donde se calcula la sumatoria de elementos de un conjunto.

\begin{lstlisting}[ style = lang, caption = Sumatoria de Conjunto Iterable, label = sumatoriaIter ]
fun sumIter ( s : set of (int) ) ret sum : int
  sum := 0
  for i in s do
    sum := i + sum
  od
end fun
\end{lstlisting}

Es relevante aclarar que a pesar de referirnos a \textbf{Iter} como una clase, aún no se ha determinado si la misma será definida como tal en el lenguaje, donde es posible que durante el desarrollo del proyecto su naturaleza sea modificada por lo que su interpretación cambie de manera acorde.

\subsection{Respecto a la Implementación}

Existe ciertos aspectos de la implementación que no han sido desarrollados por completo, o más bien, podrían ser mejorados para ofrecer un lenguaje más sofisticado.

\subsubsection{Generación de Múltiples Errores}

Uno de los aspectos que se puede mejorar de la implementación del lenguaje, es la generación de múltiples errores tanto en la etapa del \textit{parser} como en la de \textit{chequeos estáticos}.
Actualmente cuando se encuentra un error durante el parsing o la verificación de un programa se aborta por completo el análisis del mismo, generando un mensaje de error sobre la causa de la falla.
Una característica deseable en el lenguaje, es poder capturar la mayor cantidad posible de errores encontrados en una determinada etapa, antes de fallar, y generar todos los mensajes necesarios correspondientes.
% IDEA: Esto obviamente beneficiaría al usuario, ya que se tendría que dedicar menor tiempo a la corrección de errores, agilizando efectivamente el uso de la herramienta, y podría destinar mayor atención al diseño de algoritmos.

\begin{itemize}

\item
\textbf{Parser}
La librería \Megaparsec{} ofrece un mecanismo para señalar múltiples errores en una sola corrida del parser.
Un requisito para utilizar esta funcionalidad es que debe ser posible omitir la sección problemática de la cadena de caracteres que estamos intentando parsear, para resumir el parseo en una posición que se considere estable.
% IDEA: ...donde comúnmente se generaría un error de parsing...
Lo cual se consigue con el uso de la función \lstinline[style = haskell]{withRecovery}, que permite continuar el parsing luego de ocurrido un error.

\item
\textbf{Chequeos Estáticos}
Una posibilidad para la generación de múltiples errores en esta etapa, está descripta en el artículo que se empleó como guía para la implementación de los chequeos estáticos~\cite{MonadicTC}.
Esta opción consiste en la implementación de un combinador, que es invocado cada vez que se deben verificar una serie de elementos sintácticos.
La idea es poder combinar la lista de chequeos a realizar y, si todos tienen éxito, se devuelven sus resultados correspondientes.
En caso contrario, se deberán acumular la totalidad de los errores producidos, y luego generar los mensajes informativos adecuados.

\end{itemize}

\subsubsection{Coersiones y Subtipado}

En el lenguaje hay dos tipos numéricos, los valores enteros y los valores reales.
En ambos casos se encuentra definido un listado de operadores sobrecargados que pueden ser utilizados para operar con cualquiera de los valores previos.
Una restricción de la implementación actual, es que ambos tipos son percibidos como valores completamente diferentes.
Lo cual significa, por ejemplo, que la operación de sumar enteros con reales es detectada como un error de tipos.
% IDEA: Al mismo tiempo, la constante \textbf{inf} es interpretada como un valor entero, al igual como sucede con los tamaños polimórficos.
Esto imposibilita implementar ciertos algoritmos donde deseamos realizar operaciones donde se combinan ambos tipos de valores numéricos, como es el caso de querer calcular el promedio de un arreglo de números reales, el cual posee un identificador para su tamaño.
El código presentado a continuación~(\ref{promedioReal}) ilustra la situación mencionada.
Notar que al chequear la última asignación de la función, el lenguaje fallará debido a un error de tipos producido por la división de un número real por uno de tipo entero.

\begin{lstlisting}[ style = lang, caption = Promedio en Arreglo de Reales, label = promedioReal ]
fun averageReal ( a : array [n] of real ) ret avg : real
  var sum : real
  sum := 0
  for i := 1 to n do
    sum := a[i] + sum
  od
  avg := sum / n {@ Type Error @}
end fun
\end{lstlisting}

\subsubsection{Inferencia de Tipos}

El sistema de tipos que se encuentra actualmente implementado puede resultar básico a la hora de resolver ciertas cuestiones debido que solo es un primer prototipo.
En consecuencia a esto se presentan algunas limitaciones, donde el algoritmo de unificación no es lo suficientemente sofisticado para resolver el polimorfismo admitido por funciones y procedimientos.
Un ejemplo particular es la llamada de las construcciones mencionadas con la constante \textbf{null}.
% IDEA: ...la cual simboliza un puntero vacío.
Tomando como ejemplo la implementación de la función~(\ref{inferenciaNull}); la cual obtiene el elemento señalado por un puntero si el mismo no es nulo, o devuelve su segundo argumento en caso contrario.
Si aplicamos la función con la llamada \lstinline[style = lang]{pointerAccess(null, 5)}, entonces se producirá un error en la etapa de chequeos estáticos del lenguaje, debido a la imposibilidad de chequear los tipos involucrados.

\begin{lstlisting}[ style = lang, caption = Ejemplo para Inferencia de Tipos, label = inferenciaNull ]
fun pointerAccess ( p : pointer of T, t : T) ret value : T
  if p == null then
    value := t
  else
    value := #p
  fi
end fun
\end{lstlisting}

% IDEA: A causa de esta constante es necesario adaptar nuestra implementación para contemplar estas situaciones.
% IDEA: En otros contextos donde se puede emplear el valor \textbf{null}, el algoritmo de chequeo de tipos es capaz de resolver esta particularidad mediante el uso de técnicas \textit{ad hoc}.
El conflicto sucede cuando es necesario inferir un tipo para la constante \textbf{null}, combinada con el polimorfismo que admite una función o un procedimiento, debido que nuestro algoritmo de unificación no es lo suficientemente sofisticado para asignarle correctamente un tipo.
% IDEA: ...lo que nos fuerza a requerir una mayor cantidad de información contextual para realizar las validaciones correspondientes.

Para resolver este limitante, se presentan dos opciones que requieren la modificación de la implementación actual.
La primera, orientada al tipado explícito, implica la adaptación de la sintaxis del lenguaje para forzar al programador a anotar el tipo concreto que tendrá la constante en el momento que se utiliza.
% IDEA: De esta forma, durante la verificación se tendrá la suficiente cantidad de información para que el \textit{juicio de tipado} sea directo.
La segunda opción, orientada al tipado implícito, supone la implementación de un algoritmo de \textit{inferencia de tipos}.
Utilizando ideas del \textit{algoritmo Hindley-Milner}~\cite{Inferencia}, se podría adecuar nuestro sistema de tipos para lograr que el mismo sea capaz de inferir los tipos apropiados, sin necesidad de anotar el tipo de nuestra constante.