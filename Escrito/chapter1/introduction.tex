% Introducción

% Estructura
\iffalse
* Un párrafo inicial donde contas a grandes rasgos el laburo. No tiene que ser para nada largo, dos oraciones alcanza y si hace falta agregamos otra.

* Motivación: contar que esta tesis es parte de un trabajo más grande que surge a partir de la experiencia en Algoritmos 2, donde se utiliza un lenguaje imperativo poco definido para enseñar los conceptos. Contar un poco de ese lenguaje, que es tipo Pascal, contar qué características tiene, qué partes están poco especificadas en la materia, contar los conceptos que se enseñan, etcétera...

* Sintaxis y chequeos estáticos: esta sección debería ser resumen de bibliografía. Leer Dragón y Reynolds y ver qué ponemos de ahí. La idea sería no mandar fruta y simplemente resumir que vamos a entender en general por sintaxis abstracta y concreta, al igual que chequeos estáticos en esta tesis.

%
A continuación introduciremos algunos conceptos generales que aparecen en el estudio y definición de cualquier lenguaje de programación, y por lo tanto en esta tesis. Particularmente nos enfocamos en la sintaxis concreta, abstracta y chequeos estáticos (no sé si me olvido algo)
- Sintaxis concreta, seguro podemos chorear del libro del dragon. La idea sería dar la definición.
- Sintaxis abstracta, acá la sección 1.1 del Reynolds seguro nos sirve para tener una mejor idea.
- Chequeos estáticos, acá pareciera que podemos usar alguito del cap15 del Reynolds y 1.2.3 del libro del dragon.
%

* Organización de la tesis: simplemente contar qué va a haber en cada uno de los capítulos siguientes.
\fi

En el siguiente proyecto desarrollaremos la semántica estática de un lenguaje de programación inspirado en el pseudocódigo utilizado por la materia \Materia{}.
A diferencia de la mayoría de los lenguajes de programación conocidos, en el trabajo se presenta un desarrollo formal del lenguaje previo a su implementación.
Se acompañará el avance del proyecto con el diseño de un intérprete adecuado.
En el escrito nos concentraremos principalmente en el estudio teórico del lenguaje, donde solo se comentarán algunos detalles sobre su implementación.
% IDEA: Partiendo de un estudio teórico de sus propiedades, se dará una definición formal del mismo que luego tendrá como resultado su implementación.
% IDEA: Con el avance del proyecto, se acompañará al desarrollo con el diseño de un intérprete adecuado.

\section{Motivación}

En la materia \Materia{}, de \Facultad{}, se utiliza desde hace años un pseudocódigo para la enseñanza de conceptos tales como análisis de algoritmos, definición de tipos abstractos de datos, o la comprensión de distintas técnicas de programación.
Este pseudocódigo está inspirado en el lenguaje imperativo \Pascal{}, diseñado por \textit{Niklaus Wirth} cerca de 1970~\cite{Pascal}, al cual se le han ido realizando modificaciones de acuerdo a las necesidades didácticas de la materia.
Algunas características que se han mantenido comprenden la sintaxis verbosa, el tipado fuerte para expresiones, y el formato estructurado del código.
% ... lenguaje Pascal [contás más características, por ejemplo como que es imperativo], al cual ...
Haciendo un análisis exhaustivo de las clases y los ejemplos en los que se utiliza el lenguaje en la materia, observamos que su definición aún no está completamente clara, y que el grado de precisión con el que se presentan los programas varía entre unas presentaciones y otras.

\begin{lstlisting}[ style = pseudo, caption = Permutación de Valores, label = pseudoSwap ]
{ PRE: 1 <= i, j <= n }
proc swap ( in / out a : array [1..n] of T, in i, j : nat )
  var temp : T
  temp := a[i]
  a[i] := a[j]
  a[j] := temp
end proc
\end{lstlisting}

Mediante los procedimientos \lstinline[style = pseudo]{swap} y \lstinline[style = pseudo]{selectionSort}, declarados en el pseudocódigo de la materia, se define un algoritmo para ordenar arreglos de menor a mayor.
Cada uno de los pasos ha efectuar por el algoritmo es detallado con precisión, por lo que es sencillo imaginar una posible ejecución del programa dado con un arreglo \lstinline[style = pseudo]{a} cualquiera.
La traducción del código a un lenguaje de programación imperativo, como por ejemplo \C{}, resulta ser casi directa.
% IDEA: No hay ambigüedades, por lo que es intuitivo saber que hacer en cada caso

\begin{lstlisting}[ style = pseudo, caption = Ordenación por Selección, label = pseudoSort ]
proc selectionSort ( in/out a : array [1..n] of T )
  var minP : nat
  for i := 1 to n do
    minP := i
    for j := i + 1 to n do
      if a[j] < a[minP] then
        minP := j
      fi
    od
    swap(a, i, minP)
  od
end proc
\end{lstlisting}

Con la función \lstinline[style = pseudo]{cambio} se busca resolver el \textit{problema de la moneda}, donde se intenta pagar un monto de dinero \lstinline[style = pseudo]{m} con la menor cantidad de monedas posibles cuyas denominaciones válidas se encuentran en el conjunto \lstinline[style = pseudo]{C}; el cual tiene una cantidad infinita de cada una.
A diferencia del ejemplo previo ciertos pasos del algoritmo resultan ambiguos, donde en el pseudocódigo se permite escribir una oración en \textit{lenguaje natural} para describir la acción a realizar durante su ejecución.
Un problema que conlleva esto para un programador no experimentado es responder a la pregunta \textit{¿Cuál es el grado de ambigüedad permitido?}
% IDEA: Claramente en esta clase de problemas se trabaja con un grado de abstracción elevado.

% FIX de comentarios!
\begin{lstlisting}[ style = pseudo, caption = Problema de la Moneda, label = pseudoCoin, otherkeywords = { \{, \} } ]
fun cambio ( m : $monto$, C : $Conjunto \; de \; Monedas$ )
ret S : $Conjunto \; de \; Monedas$
  var c, resto : $monto$
  S := {} #\ttfamily \itshape \color{OliveGreen} \{ Inicializamos S con el conjunto vacío \}#
  resto := m
  while resto > 0 do
    c := $mayor \; elemento \; de$ C
    C := C - {c}
    S := S $\color{RoyalBlue} \cup$ { resto div c $monedas \; de \; denominaci \acute{o} n$ c }
    resto := resto mod c
  od
end fun
\end{lstlisting}

% [Acá pondría ejemplos de eso. Algunos donde el lenguaje sea bien preciso, y otros donde haya un grado de abstracción e imprecisión grande].

En este trabajo nos proponemos definir con precisión un lenguaje como el que se utiliza en la materia, que permita al estudiante poder implementar y correr los algoritmos presentados en el teórico y práctico.
Además del beneficio desde el punto de vista didáctico, la definición formal y la implementación de un lenguaje con estas características reviste interés propio.
En el mismo se utilizan algunos conceptos avanzados de lenguajes de programación como el polimorfismo paramétrico, una variante primitiva de polimorfismo \textit{ad hoc}, el manejo de memoria dinámica mediante punteros, pasaje por valor y referencia mediante funciones y procedimientos, entre otros.
% [Quizás se puede presentar mejor esas características interesantes del lenguaje].
Para lograr el objetivo propuesto debemos primero definir precisamente la sintaxis del lenguaje, identificar las ambigüedades que naturalmente tiene debido al uso didáctico con el que fue creado, luego definir chequeos estáticos como el tipado, el alcance de variables, atributos sobre parámetros de funciones y procedimientos, entre otros.
En una segunda etapa, que excede esta tesis, se definirá formalmente la semántica dinámica y un intérprete interactivo que permita ejecutar algoritmos observando el estado paso a paso.

% Motivación
\iffalse
En la materia \Materia{}, durante varios años se ha utilizado un pseudocódigo para la enseñanza de conceptos tales como el análisis de algoritmos, la abstracción de tipos de datos, y la aplicación de diversas técnicas de programación.
Originalmente el pseudocódigo se basó en el lenguaje imperativo \Pascal{}, diseñado por \textit{Niklaus Wirth} cerca de 1970~\cite{Pascal}.
Algunas características básicas compartidas comprenden la sintaxis verbosa, el tipado fuerte, y el formato estructura del código.
% IDEA: El lenguaje ha diseñar, basado en el pseudocódigo, tendrá un fin didáctico con el que se busca ofrecer otra fuente de aprendizaje para asistir al dictado de la asignatura.
% IDEA: Los ejes principales de la materia consisten en el análisis de algoritmos, la definición de tipos abstractos de datos, y la comprensión de diversas técnicas de programación.

El objetivo del pseudocódigo es poder introducir a los estudiantes a nuevos conceptos y fomentar buenas prácticas de programación.
% Corregir:
% + La idea era que el nivel de detalle/precisión se ajusta de acuerdo al tema que se quiere explicar
% + Para mi la parte de pseudocódigo tiene que ver más con el escribir "oraciones en lenguaje natural" o usando matemática medio pesada
Se utiliza para describir de forma precisa principios operacionales de los algoritmos estudiados en la materia.
No existe ningún estándar para la sintaxis o semántica del pseudocódigo, por lo que se manifiestan ciertas ambigüedades al declarar programas con el mismo.
% IDEA: Un programa en este lenguaje no es ejecutable, en el sentido que no puede ser traducido a una serie de instrucciones máquina.
% IDEA: Se utiliza para describir de forma precisa principios operacionales de los algoritmos estudiados en la materia, donde típicamente se omiten detalles esenciales sobre la implementación de algoritmos para favorecer su entendimiento.

% Corregir:
% + Lo hacemos porque podemos
El propósito final del proyecto, es poder tomar los fragmentos de pseudocódigo que se encuentran dispersos en los contenidos de la materia, y transformarlos en un lenguaje formal con una justificación teórica apropiada.
El principal desafío para cumplir nuestra tarea, será poder resolver las ambigüedades y la falta de especificación que el pseudocódigo presenta.
% IDEA: Con fundamentos teóricos...
\fi

% Objetivos y Programa de la Asignatura
\iffalse
\subsection{Objetivos de la Asignatura}

Durante el desarrollo de la materia, se pretende que el alumno adquiera diversos conceptos relacionados con los temas estudiados en la asignatura.
Algunos de los cuales son listados a continuación:
\begin{itemize}
    \item Capacidad para comprender y describir el problema que resuelve un algoritmo (el \textit{qué}), y diferenciarlo de la manera en que lo resuelve (el \textit{cómo}).
    \item Capacidad para analizar algoritmos, compararlos según su eficiencia en tiempo de ejecución y en espacio de almacenamiento.
    \item Capacidad para identificar abstracciones relevantes al abordar un problema computacional, y separar su especificación de su implementación.
    \item Familiaridad con técnicas de diseño de algoritmos de uso frecuente, y comprensión de diversos algoritmos conocidos.
\end{itemize}

\subsection{Programa de la Asignatura}

El contenido de la materia se puede dividir en tres unidades, donde en cada una se introducen conceptos que luego se reflejan en fragmentos de pseudocódigo empleados para facilitar su enseñanza.
En el diseño del futuro lenguaje, se deberán tener en cuenta estas cuestiones para poder crear una herramienta útil para complementar el dictado de la asignatura.
\begin{itemize}
    \item \textbf{Análisis de Algoritmos}:
    Se estudian distintas maneras de ordenar arreglos utilizando diversas técnicas, como \textit{ordenación por selección}, \textit{ordenación por inserción}, \textit{ordenación por intercalación}, \textit{ordenación rápida}, entra otras.
    Se enseña al alumno a contar operaciones de un programa, introduciendo de esta manera los conceptos de \textit{orden} y \textit{jerarquía} sobre la complejidad de un algoritmo.
    Se introducen las recurrencias \textit{divide y vencerás}, y se presentan otros algoritmos como la \textit{búsqueda lineal}, y la \textit{búsqueda binaria}.
    \item \textbf{Estructura de Datos}:
    Se describen los \textit{tipos concretos} como un concepto relativo a un lenguaje de programación, donde se estudian elementos como los arreglos, las listas, los registros, y los tipos enumerados; mientras que los \textit{tipos abstractos} se presentan como una idea asociada a un problema que se quiere resolver.
    Se describe la diferencia entre su \textit{especificación}, y su \textit{implementación}, y se enseña la importancia de su elección adecuada.
    Se examinan diseños distintos para varios de los diversos \textit{TAD's}, como el \textit{contador}, la \textit{pila}, la \textit{cola}, y el \textit{árbol}, junto con la eficiencia en tiempo y espacio de sus operaciones.
    Se introduce el concepto de \textit{manejo dinámico de memoria} de un programa mediante el uso de punteros.
    \item \textbf{Algoritmos Avanzados}:
    Se presentan distintas estrategias conocidas para la resolución de problemas algorítmicos.
    Se introduce el esquema general de los \textit{algoritmos voraces}, y se enseñan diversos algoritmos basados en esta idea como los de \textit{Dijkstra}, \textit{Prim}, y \textit{Kruskal}.
    También se introduce al concepto de \textit{backtracking}, resolviendo los problemas de la \textit{moneda}, y la \textit{mochila}, entre otros.
    Se estudia \textit{programación dinámica} donde se visitan problemas previos, además de ver nuevos conceptos como el algoritmo de \textit{Floyd}.
    Un último tema que se enseña en la materia, es la recorrida de grafos, y las distintas variantes para su realización.
\end{itemize}
\fi

\section{Conceptos}

% IDEA
\iffalse
% Chequeos Estáticos
son estáticos porque no hace falta tener definida una noción de evaluación para su definición
% Sintaxis Concreta
La sintaxis concreta define exactamente que cadenas de caracteres serán consideradas programas del lenguaje y por lo general consiste de un conjunto de reglas, también llamadas producciones, que definen la manera de declarar programas de acuerdo a una gramática libre de contexto del lenguaje.
% Sintaxis Abstracta
podes hacer notar que para definir la semántica estática del lenguaje no hace falta tener una "versión" tan pedante y nos alcanza con enfocarnos en lo importante, y acá presentas la sintaxis abstracta
\fi

A continuación introduciremos algunos conceptos generales que muy probablemente aparecen en el estudio y definición formal de cualquier lenguaje de programación, y por lo tanto también en este trabajo.
Particularmente nos enfocaremos en la sintaxis, concreta y abstracta, y los chequeos estáticos.

La \textbf{sintaxis concreta} define que cadenas de caracteres serán consideradas programas del lenguaje, es decir los programas que uno finalmente escribe son caracterizados por esta gramática, y por lo general consiste de un conjunto de reglas, también llamadas producciones, que definen la manera de declarar programas de acuerdo a una \textit{gramática libre de contexto} del lenguaje.
Notar que si esta gramática define como mencionamos qué programas están correctamente escritos, entonces es porque contempla detalles precisos de la escritura de las construcciones del lenguaje como los caracteres válidos para nombrar variables, las llaves para delimitar bloques de código, o las palabras claves correspondientes para denotar determinadas construcciones.
Por ejemplo, si consideramos el lenguaje de programación \C{} podríamos definir un pequeño fragmento de su sintaxis concreta para la declaración de funciones:
\begin{gather*}
\NT{concreteFun} ::= \NT{type} \; \NT{id} \; ( \; [ \; \NT{id} : \NT{type} \; ]^* \; ) \; \{ \; \NT{body} \; \}
\end{gather*}

Asumiendo tenemos definidas las gramáticas para el resto de las construcciones no terminales $\NT{type}$, $\NT{id}$, y $\NT{body}$, notar que escribir una función en \C{} consiste de escribir el tipo de retorno, su nombre seguido de los parámetros que necesariamente deben estar encerrados entre paréntesis y separados por comas, y finalmente entre llaves escribimos el cuerpo de la función.
Por ejemplo, un fragmento de la implementación de \texttt{factorial} puede ser:
\begin{gather*}
\texttt{int} \; \texttt{factorial} \; ( \texttt{n} : \texttt{int} ) \; \{ \; body_{conc} \; \}
\end{gather*}

Todos estos detalles burocráticos de escritura son importantes ya que, si bien algunas veces la sobrecargan, ayudan entre otras cosas a la lectura y organización del código.
Sin embargo, una representación más abstracta de las componentes sintácticas que definen un programa suele resultar más conveniente para el estudio formal de propiedades como el chequeo de tipos, entre otras.
Así como también una representación interna de un programa en la implementación de un intérprete y/o compilador.
% IDEA: Se utiliza un \textit{árbol de sintaxis concreta} para representar la derivación de un programa a través de las reglas de la respectiva sintaxis.
% IDEA: Un intérprete toma un fragmento de texto, el cual debe respetar la definición de las reglas sintácticas, y lo convierte en una representación intermedia del programa.
% IDEA: El proceso de transformación es llevado a cabo por las etapas de \textit{análisis léxico} y \textit{análisis sintáctico} del intérprete.
% IDEA: Notar que si se quisiera hacer un estudio del lenguaje, utilizar su sintaxis concreta puede agregar complicaciones innecesarias.
% IDEA: Los programas del lenguaje no son simplemente cadenas de caracteres, sino entidades abstractas representadas por cadenas de caracteres.
% IDEA: Donde la gramática declarada solo captura detalles sobre la estructura concreta de las frases del lenguaje.

La \textbf{sintaxis abstracta} define de manera independiente de cualquier representación particular a las \textit{frases abstractas} que conforman a un lenguaje.
Definiendo una \textit{gramática abstracta} nos enfocamos solo en la información que nos resulta importante de una frase, omitiendo por lo tanto detalles de su representación específica.
Una posible representación abstracta de las funciones de \C{} es la siguiente, donde la declaración de una función (en su versión abstracta) tendrá que tener un nombre, sus argumentos, un tipo de retorno, y el cuerpo; omitiendo por ejemplo la escritura concreta de llaves, e incluso el orden en que aparecen las componentes puede resultar irrelevante.
Es importante aclarar que los no terminales que no poseen producciones, son definidos de manera abstracta de forma análoga a los asumidos en la sintaxis concreta.
\begin{gather*}
\NT{abstractFun} ::= \texttt{CFun} \; \NT{id} \; ( \NT{id}, \NT{type} )_1 \ldots ( \NT{id}, \NT{type} )_n \; \NT{type} \; \NT{body}
\end{gather*}

Finalmente dadas ambas sintaxis podemos definir una función de traducción de la sintaxis concreta a la abstracta, comúnmente llamada \textbf{parser}.
Luego la traducción de la función \texttt{factorial} que escribimos anteriormente nos construye la siguiente versión abstracta.
\begin{gather*}
\texttt{CFun} \; \texttt{factorial} \; ( \texttt{n}, \texttt{int} ) \; \texttt{int} \; body_{abs}
\end{gather*}
% IDEA: Mediante un \textit{árbol de sintaxis abstracta} se puede derivar cualquier frase del lenguaje, donde cada nodo denota uno de los elementos que la constituyen.
% IDEA: Los programas de un lenguaje formal no son simplemente cadenas de palabras, sino más bien entidades abstractas representadas por cadenas de palabras.
% IDEA: La \textit{sintaxis abstracta} de un lenguaje caracteriza el conjunto de frases abstractas que pueden ser especificadas en el, permitiendo ignorar la información irrelevante sobre como representar las frases de manera concreta, y solo capturando su naturaleza.
% IDEA: Se enfoca la atención en la información sobre la naturaleza de las frases, omitiendo detalles acerca de su representación específica como los caracteres utilizados para denotar variables y constantes, o la precedencia y asociatividad de los operadores.
% IDEA: Una vez definida la sintaxis, es posible dar semántica al lenguaje de acuerdo a las frases construidas por ella.

\iffalse
Al estudiar un lenguaje se utiliza la sintaxis abstracta como una notación simple para representar sus frases, ignorando las complicaciones inherentes a sus respectivas estructuras.
Notar que las gramáticas abstractas, al ser interpretadas como gramáticas libres de contexto, pueden resultar ser ambiguas.
De todas maneras la principal utilidad de la herramienta radica en que permite abstraer los conceptos fundamentales de las construcciones del lenguaje.
A continuación se precisa nuevamente la declaración anterior mediante la gramática presentada.
\fi

\iffalse
% Versión Previa de Chequeos Estáticos
Los \textbf{chequeos estáticos} utilizan el \textit{árbol de sintaxis abstracta} para verificar consistencia semántica en el programa de acuerdo a la definición del lenguaje.
Se emplea un conjunto de \textit{reglas de tipado} para garantizar determinadas propiedades de manera estática, las cuales son independientes de la noción de evaluación del lenguaje.
Una tarea importante del análisis es el \textit{chequeo de tipos}, donde se verifica que todo operador tenga operandos válidos.
Además se comprueba que elementos como las variables o las constantes hayan sido declarados previo a su uso en el programa.
% IDEA: Siendo una de las etapas de la interpretación del código, se emplea un conjunto de \textit{reglas de tipado} para garantizar determinadas propiedades de manera estática, antes de la ejecución del programa.
\fi

Claramente no cualquier cadena de caracteres conforma un programa \textit{bien escrito}, esto ocurre cuando al aplicar la función de traducción esta nos construye una frase abstracta.
Sin embargo la construcción exitosa de la frase no significa que no existan errores; solo significa que el programa está correctamente escrito según las cadenas que caracteriza la sintaxis concreta.
Todavía pueden existir errores como el uso de variables no declaradas, llamadas de funciones con una cantidad incorrecta de argumentos, o para el caso de lenguajes tipados, errores de tipo.
Para capturar esta clase de errores definimos los \textbf{chequeos estáticos} que serán propiedades que le pediremos a un programa bien escrito y que podemos verificar sin ejecutarlo.
Estos se definen sobre las frases abstractas aprovechando, como ya mencionamos, que solo cargan la información relevante de un programa concreto.
Definiendo \textit{juicios de tipado} (enunciados que establecen cuando una frase abstracta tiene un determinado tipo) podemos dar una prueba que establezca cuando un programa no tiene errores de tipo; al poder asignarle uno. De igual manera es posible definir otras clases de enunciados para el resto de los chequeos.
% IDEA: Los chequeos emplean un conjunto de \textit{reglas de tipado} para garantizar determinadas propiedades de manera estática, las cuales son independientes de la noción de evaluación del lenguaje.
% IDEA: Los cuales utilizan el \textit{árbol de sintaxis abstracta} obtenido luego de aplicar la traducción sobre la cadena de caracteres.
% IDEA: Los chequeos estáticos son propiedades que le pediremos a un programa bien escrito y que podemos verificar sin ejecutarlo.

Si chequeamos estáticamente la frase abstracta correspondiente con el ejemplo de la función \texttt{factorial}, deberíamos poder verificar que esta toma un entero y devuelve un entero, es decir que tiene tipo \textit{int en int}.
Es fundamental notar que al efectuar los chequeos sin ejecutar el programa, es posible que sigan existiendo errores que solo podrán ser capturados durante su ejecución, como la división por cero, o accesos de memoria no válidos, entre otros.

\iffalse
Supongamos que se analiza la función \texttt{factorial} declarada previamente.
Mediante una prueba, es posible demostrar la existencia del juicio de tipado que asegura que la función tiene tipo de \textit{enteros en enteros}.
A lo largo de la verificación del programa, se utilizará esta información para evitar cualquier llamada a la construcción que no respete su tipo.
\fi

% IDEAS
\iffalse
Claramente no cualquier cadena de caracteres es un programa válido, de hecho la tarea que realiza la función de traducción es asegurar que se evitan determinados errores de escritura en la declaración de un programa.
Si bien se obtienen programas \textit{bien escritos}, la traducción de sintaxis no es suficiente para capturar todos los errores de un programa.
Los \textbf{chequeos estáticos} utilizan el \textit{árbol de sintaxis abstracta}, obtenido luego de la traducción, para verificar consistencia en el significado de las construcciones de un programa de acuerdo a la definición del lenguaje.
Se emplea un conjunto de \textit{reglas de tipado} para garantizar determinadas propiedades de manera estática, las cuales son independientes de la noción de evaluación del lenguaje.
\fi

\iffalse
% Observaciones sobre Chequeos Estáticos
Habría que agregar algo más concreto sobre otros chequeos (quizá la última oración lo hace).

Claramente no cualquier cadena de caracteres es un programa válido de hecho el trabajo que hace la función de traducción \textit{parser} es asegurarnos que nos evitamos determinados errores de escritura
Nos da pie para comentar que si bien ahora tenemos programas \textit{bien escritos} aun así, estos pueden contener errores

Igual habría que mencionar que es solo otra etapa de \textit{captura de errores}, porque también puede haber errores cuando se ejecuta el programa

La mayor parte de los chequeos estáticos van a ser en relación al chequeo de tipos (acá podes contar si quieres, que esto pasa en general para los lenguajes tipados) pero que no necesariamente siempre es así
\fi

\iffalse
% Sintaxis Abstracta
\item
La \textbf{sintaxis abstracta} representa las entidades abstractas conformadas por las cadenas de caracteres de origen, de manera independiente de sus detalles de representación específicos.
Lo cual es convertido en un \textit{árbol de sintaxis abstracta}, donde cada nodo denota una construcción en el código fuente.
% Sintaxis Concreta
\item
La \textbf{sintaxis concreta} representa la estructura sintáctica de un programa de acuerdo a la \textit{gramática libre de contexto} del lenguaje.
Caracterizan las cadenas de caracteres de origen que luego serán convertidas en un programa interpretado.
\fi

\iffalse
- Sintaxis concreta, seguro podemos chorear del libro del dragon. La idea sería dar la definición.
- Sintaxis abstracta, acá la sección 1.1 del Reynolds seguro nos sirve para tener una mejor idea.
% yo diría que es justamente la posibilidad de abstraer las componentes relevantes de las frases de un lenguaje
% - La no linealidad de lectura de las expresiones abstractas - La abstracción de los conceptos de manera que sean independientes de su representación concreta
- Chequeos estáticos, acá pareciera que podemos usar alguito del cap15 del Reynolds y 1.2.3 del libro del dragon.
\fi

\section{Organización de la Tesis}

El escrito se divide en cinco capítulos.
En el capítulo 2 se presenta el lenguaje, donde se ilustran sus características más relevantes a través de ejemplos.
En el capítulo 3 se describe la sintaxis abstracta y se presenta la sintaxis concreta, además se detallan aspectos sobre la implementación del parser del lenguaje.
En el capítulo 4 se definen formalmente los chequeos estáticos, y se lo acompaña con derivaciones de ejemplos.
En el capítulo 5 se concluye el trabajo con un breve resumen de las actividades desarrolladas y un listado de trabajos futuros.
% IDEA: Servirá como una especie de tutorial para el lector con experiencia en programación imperativa.
% IDEA: Además se detallan las características del parser de nuestro intérprete.
% IDEA: A través de una serie de reglas de tipado, junto con derivaciones de ejemplos, se fundamentan las propiedades a verificar en un programa.
% IDEA: Se acompaña con un listado de trabajos futuros con la finalidad de encaminar la evolución a posterior del lenguaje.

\iffalse
% Versión Previa
En el siguiente trabajo, desarrollaremos un lenguaje de programación para la materia \Materia{}.
Antes de comenzar propiamente con la definición formal e implementación del mismo, lo correcto es presentar los objetivos que nos hemos impuesto para la creación del lenguaje, y las motivaciones que nos han impulsado al desarrollo de este proyecto.
Por lo tanto, la siguiente sección introducirá al lector los distintos aspectos que influyeron la formación del lenguaje, y justificaron la realización de este trabajo.

\section{Motivación}

En la materia \Materia{}, durante varios años, se ha utilizado un pseudocódigo para la enseñanza de los distintos conceptos que se estudian en la misma.
Debido a esto, el lenguaje que diseñamos (basado en este pseudocódigo) tendrá un fin didáctico, y busca ser otra fuente de aprendizaje para auxiliar el dictado de la asignatura.
Los ejes principales de la materia consisten en el análisis de algoritmos, la definición de tipos abstractos de datos, y la comprensión de diversas técnicas de programación.

El objetivo del pseudocódigo es poder introducir a los estudiantes a nuevos conceptos y fomentar buenas prácticas de programación.
Se utiliza para describir de forma precisa principios operacionales de los distintos algoritmos estudiados en la materia.
Típicamente, se omiten detalles esenciales para la implementación de los algoritmos para favorecer el entendimiento de los mismos.
No existe ningún estándar para la sintaxis o semántica del pseudocódigo, por lo que un programa en este pseudo-lenguaje  no es ejecutable en el sentido que no puede ser traducido a una serie de instrucciones máquina.

Nuestra meta final con este proyecto, es poder tomar la totalidad de los fragmentos de pseudocódigo que se encuentran dispersos en los diversos contenidos de la materia, y transformarlos en un lenguaje completamente implementado, con todo lo que esto implica.
Obviamente, nuestro principal desafío para cumplir nuestra tarea, es poder resolver las distintas ambigüedades y la falta de especificación que el actual pseudocódigo presenta.

\subsection{Objetivos de la Asignatura}

Durante el desarrollo de la materia, se pretende que el alumno adquiera diversos conceptos relacionados con los distintos temas estudiados en la asignatura.
Algunos de los mismos son listados a continuación:
\begin{itemize}
    \item Capacidad para comprender y describir el problema que resuelve un algoritmo (el \textit{qué}), y diferenciarlo de la manera en que lo resuelve (el \textit{cómo}).
    \item Suficiencia para analizar algoritmos, compararlos según su eficiencia en tiempo de ejecución y en espacio de almacenamiento.
    \item Hábito de identificar abstracciones relevantes al abordar un problema computacional, y aptitud para la especificación e implementación de las mismas.
    \item Familiaridad con técnicas de diseño de algoritmos de uso frecuente, y comprensión de diversos algoritmos conocidos.
    \item Contacto con la programación (principalmente en el lenguaje \C{}) de algoritmos y estructura de datos.
    \item Aptitud para la utilización de diversos niveles de abstracción y adaptación a distintos lenguajes de programación.
\end{itemize}

\subsection{Programa de la Asignatura}

El contenido de la materia se puede dividir en tres unidades.
En cada una de estas, se introducen nuevos conceptos que luego se reflejan en diversos fragmentos de pseudocódigo empleados para facilitar la comprensión de los mismos.
En el diseño del futuro lenguaje, se deberán tener en cuenta todas estas cuestiones para poder crear una herramienta útil para complementar la enseñanza de la asignatura.

\subsubsection{Análisis de Algoritmos}

La primer unidad de la materia, se basa en el análisis de algoritmos.
Inicialmente, se estudian distintas maneras de ordenar arreglos utilizando diversas técnicas, como \textit{ordenación por selección}, \textit{ordenación por inserción}, \textit{ordenación por intercalación}, \textit{ordenación rápida}, entra otras.
Con estos contenidos básicos presentes, se enseña al alumno a contar operaciones de un programa, introduciendo de esta forma los conceptos de \textit{orden} y \textit{jerarquía} sobre la complejidad de un algoritmo.
Para terminar, se introducen las recurrencias \textit{divide y vencerás}, y se presentan otros algoritmos como la \textit{búsqueda lineal}, y la \textit{búsqueda binaria}.

\subsubsection{Estructura de Datos}

La segunda parte de la materia, presenta la noción de estructuras de datos.
Se describen a los \textit{tipos concretos} como un concepto relativo a un lenguaje de programación, donde se estudian elementos como los arreglos, las listas, los registros, y los tipos enumerados.
Mientras, los \textit{tipos abstractos} se presentan como una idea asociada a un problema que se quiere resolver.
Se describe la diferencia entre la \textit{especificación}, y la \textit{implementación} de los mismos, y se enseña la importancia de la elección adecuada para estos.
Se examinan diseños distintos para varios de los diversos \textit{TAD's}, como el \textit{contador}, la \textit{pila}, la \textit{cola}, y el \textit{árbol}, junto con la eficiencia en tiempo o espacio de sus distintas operaciones.
Además, se introduce el concepto de \textit{manejo dinámico de memoria} de un programa mediante el uso de punteros.

\subsubsection{Algoritmos Avanzados}

La última unidad, presenta distintas estrategias conocidas para la resolución de problemas algorítmicos.
Se introduce el esquema general de los \textit{algoritmos voraces}, y se enseñan diversos algoritmos que se basan en esta idea como el de \textit{Dijkstra}, \textit{Prim}, y \textit{Kruskal}.
También se introduce al concepto de \textit{backtracking}, resolviendo los problemas de la \textit{moneda}, y la \textit{mochila}, entre otros.
Luego, se ve \textit{programación dinámica} donde se visitan problemas previos, además de ver nuevos conceptos como el algoritmo de \textit{Floyd}.
Un último tema que se enseña en la materia, es la recorrida de grafos, y las distintas variantes para realizar la misma.

\section{Características del Lenguaje}

Una vez detallados los fundamentos en los que se basa el lenguaje, es hora de describir sus características más importantes.
\Lenguaje{} es una formalización del pseudocódigo utilizado en la materia \Materia{}, por lo que está diseñado para enseñar conceptos fundamentales de forma clara y natural.
Es un lenguaje imperativo similar a \Pascal{}.
Este último fue diseñado por \textit{Niklaus Wirth} cerca de 1970~\cite{Pascal}.
Algunos elementos básicos que comparten son:
\begin{itemize}
    \item Una sintaxis verbosa, pero fácil de leer.
    \item Un tipado fuerte para las expresiones.
    \item Un formato estructurado del código.
\end{itemize}

Al solo contar con una definición informal e incompleta del pseudocódigo, tuvimos que enfrentarnos a problemas de ambigüedad y falta de especificación para la creación del lenguaje.
Debido a esto, la transición de uno a otro puede no ser inmediata.
De todas formas, la esencia de ambos es la misma.
La sintaxis del lenguaje es rigurosa, en comparación al código de la materia que era flexible en este aspecto.
La semántica del primero está definida de forma precisa, a diferencia del pseudocódigo que solo se contaba con la intuición del lector para interpretar la misma.

\subsection{Tipado}

Como mencionamos previamente, \Lenguaje{} posee tipado fuerte.
Esto significa que no se permiten violaciones de los tipos de datos, es decir, dado el valor de una variable de un tipo determinado, no se puede usar la misma como si fuera de otro tipo distinto al especificado en el programa.
En una primera instancia, no hay ninguna especie de conversión, implícita o explícita, para los tipos de las expresiones del lenguaje.

En \Lenguaje{} se ofrecen una serie de tipos nativos un poco más limitada a la utilizada en el pseudocódigo de la materia.
Los mismos, a su vez, se pueden dividir en tipos básicos y en tipos estructurados.
Al mismo tiempo, existe la posibilidad de definir nuevos tipos de datos en el lenguaje; aspecto fundamental para el desarrollo de la segunda unidad de la asignatura.

Los tipos nativos básicos del lenguaje son los enteros, los reales, los booleanos y los caracteres.
Para manipular valores de estos tipos, se ofrecen las operaciones aritméticas y lógicas típicas.
A su vez, también se encuentran definidas las operaciones de igualdad y orden para estos valores, a pesar que su aplicación no se limita solo a los mismos.

Por otro lado, los tipos estructurados incorporados son los arreglos y los punteros.
Los primeros tendrán un funcionamiento similar a los especificados en el lenguaje \C{}.
Además, existirá la posibilidad de definir arreglos multidimensionales, y arreglos cuyos tamaños serán variables.
Los segundos, permitirán el manejo dinámico de la memoria de un programa y serán útiles para la creación de nuevos tipos de datos.

Finalmente, el usuario podrá crear sus propios tipos de datos.
Hay tres posibilidades para la declaración de estos.
Los tipos enumerados representarán una enumeración de un conjunto finito de valores.
Los sinónimos serán un renombrado de un tipo ya existente.
Y las tuplas permitirán la creación de estructuras con múltiples campos.
Todos estos elementos serán fundamentales para el estudio de los \textit{TAD's} en la materia.

Similar a \Haskell{}, en el lenguaje existen ciertas clases predefinidas que caracterizan el comportamiento de los tipos que las implementan.
Estas son \textbf{Eq}, \textbf{Ord}, e \textbf{Iter}.
La primera, será implementada por todos los tipos que se pueden igualar.
La segunda, es satisfecha por las categorías de elementos que son ordenables.
Finalmente, la última clase indica si cierta estructura puede ser recorrida de forma iterativa.
Una vez que el usuario declara un tipo, puede implementar todas las operaciones que una determinada clase requiera, para convertir a su nueva estructura de datos en una instancia de la misma.

\subsection{Polimorfismo}

El lenguaje permite la declaración de funciones y procedimientos con polimorfismo paramétrico.
Esto significa que con una única definición, independiente de los tipos específicos de las entradas polimórficas, las funciones y procedimientos tendrán la capacidad de ser aplicables a argumentos con valores de distinto tipo.
A su vez, esto introduce la capacidad de trabajar con variables de tipo en el programa, cuyos tipos concretos serán resueltos en tiempo de ejecución.

Otra posibilidad que permite el lenguaje, es agregar restricciones de clases que deberán ser satisfechas por las variables de tipo que los procedimientos y funciones introducen en su prototipo.
Con este refinamiento, uno puede abstraerse de los tipos específicos en la implementación, para solo considerar las operaciones básicas que los mismos proporcionan.
De esta forma, podemos limitarnos a trabajar con valores que ofrecen ciertas propiedades como la de igualdad, la de orden, y la de ser iterables.

El polimorfismo que admiten las funciones y procedimientos del lenguaje no se limita solo a tipos.
También existe una especie de polimorfismo para los tamaños de arreglos que se introducen en la declaración de los anteriores.
Con esta posibilidad, se pueden definir funciones o procedimientos que operan sobre arreglos, independientemente del tamaño de estos.
Esto introduce la capacidad de trabajar con tamaños variables de arreglos, cuyo tamaño concreto será resuelto durante la ejecución del programa.

\subsection{Recursión}

La recursión es otro de los temas fundamentales en el dictado de la materia.
En particular, para la parte de conteo de operaciones, donde se estudia como calcular el \textit{orden} de un algoritmo.
Dentro del cuerpo de una función o procedimiento, se puede realizar una llamada recursiva a si mismo para continuar con la ejecución del programa.
En estas situaciones, el lenguaje no presenta ninguna particularidad relevante como para ser mencionada en esta sección.

En cambio, donde si haremos una salvedad, es en la declaración de tipos de datos.
En el lenguaje, solo se permite una clase de recursión muy limitada para los mismos.
Para crear un tipo recursivo, solo hay una posibilidad bastante restrictiva, y es en la definición de una tupla que posea un campo de tipo puntero.
Esta especie de recursión es lo suficientemente expresiva como para permitir la implementación de listas enlazadas en el lenguaje, concepto fundamental en el programa de la asignatura.

\subsection{Manejo de Memoria}

Una característica muy importante del pseudocódigo, que se sigue manteniendo en el lenguaje, es el manejo dinámico de memoria.
Durante la segunda y tercera parte de la materia, este es un concepto central que acompaña al desarrollo de la asignatura.
Para la implementación de \textit{TAD's}, resulta un tema recurrente que sirve para comparar distintos diseños en base a su claridad, portabilidad, y eficiencia.

Mediante el uso de punteros, y la llamada de los procedimientos especiales \textbf{alloc} y \textbf{free}, el usuario puede hacer un uso explícito sobre la memoria utilizada por el programa.
Con algunos conceptos similares a \C{}, uno puede reservar memoria que será accesible mediante el uso de punteros.
Durante la ejecución del programa, se podrá manipular la memoria reservada y, cuando ya no sea necesaria, se podrá liberar la misma.

\subsection{Encapsulamiento}

Una última característica relevante que fue tomada de los contenidos de la materia y sentó las bases para el desarrollo del lenguaje, es el encapsulamiento.
En el pseudocódigo esta particularidad muchas veces era omitida, debido que un programa en este pseudo-lenguaje solo se podía ejecutar \textit{en el aire}.
Debido a esto, se contaba con una intuición sobre que era parte de la especificación y que era parte de la implementación de un tipo de dato, de manera informal.

Cuando pasamos al lenguaje formal, hay una evidente diferenciación entre el código que se utiliza para especificar un \textit{TAD}, y el código empleado para su implementación.
En \Lenguaje{} se busca tener una clara separación en módulos para los elementos definidos de un programa.
De esta forma, podemos abstraernos de los detalles propios de la implementación de una estructura de datos, y basarnos solo en su especificación para resolver cierto problema algorítmico.

\section{Desarrollo del Intérprete}

Debido que el objetivo de este proyecto es la creación de un lenguaje de programación, nuestro ideal es que el producto final del trabajo sea la implementación de un intérprete para el mismo.
El desarrollo de esta herramienta no es una actividad trivial, por el contrario, su avance requerirá de múltiples iteraciones y se dividirá en distintas etapas donde, a medida que se progrese en el proyecto, habrá una retroalimentación mutua entre las mismas.
Con respecto a este trabajo de tesis en particular, realizaremos la implementación para la primera versión de la fase de \textit{análisis} del intérprete.
En la misma, luego de definir la sintaxis del lenguaje, desarrollaremos tanto el parser como los chequeos estáticos que conforman esta etapa.

A continuación, daremos un breve marco teórico sobre distintas cuestiones que consideramos importante mencionar sobre el diseño del intérprete en general.
Para el mismo, nos basaremos en los primeros capítulos de la bibliografía de Aho, Sethi y Ullman~\cite{Dragon}.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{Compilador.png}
\caption{Un compilador}
\label{Compilador}
\end{figure}

Un lenguaje de programación es una notación para describir computaciones a personas y a máquinas.
Pero para que un programa sea ejecutable, antes debe ser traducido a un formato comprensible para una máquina.
Los sistemas de software que se encargan de esta traducción son denominados \textit{compiladores}.
De forma simple, un compilador es un programa que puede leer un programa especificado en un \textit{lenguaje fuente} y traducirlo en un programa equivalente en un \textit{lenguaje objetivo}.
En la imagen~\ref{Compilador} se puede observar un esquema simplificado de esta idea.

Un intérprete es otra clase común de procesador de lenguajes.
En lugar de producir un programa objetivo como resultado de una traducción, un intérprete simula ejecutar directamente las operaciones especificadas en el programa fuente, en base a las entradas suministradas por el usuario y retornando las salidas producidas como resultado de la ejecución.
En la figura~\ref{Intérprete} se puede apreciar la diferencia esencial entre ambas clases de procesadores de lenguajes.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{Interprete.png}
\caption{Un intérprete}
\label{Intérprete}
\end{figure}

Si entramos un poco más en detalle, podemos observar que el proceso de transformación está compuesto por dos etapas: \textit{análisis} y \textit{síntesis}.
En el caso de la primera etapa, su desarrollo puede realizarse de manera idéntica tanto para compiladores como para intérpretes.
En cambio, la segunda presenta diferencias sustanciales entre ambos.
Debido que nuestro objetivo es implementar un intérprete para el lenguaje, nos concentraremos solo en el estudio de este.

\subsection{Análisis}

La parte del análisis divide el programa fuente en distintas piezas e impone una estructura gramatical a las mismas.
Luego, utiliza esta estructura para crear una representación intermedia del programa fuente.
Si la etapa de análisis detecta que el programa presenta errores sintácticos o incoherencias semánticas, entonces deberá proveer mensajes informativos para que el usuario pueda aplicar las correcciones adecuadas.
En nuestro caso, la representación intermedia que utilizaremos serán los \textit{arboles de sintaxis abstracta}.
La transformación del programa fuente a nuestra representación intermedia, no es trivial.
Para facilitar la misma, comúnmente se divide esta tarea en varias fases.

\subsubsection{Análisis Léxico}

En esta etapa, también llamada \textit{fase de escaneo}, se analiza la entrada carácter por carácter y se divide la misma en una serie de unidades elementales denominadas \textit{componentes léxicos}.
Por cada componente léxico, la fase de escaneo produce como salida un \textit{token} que pertenece a cierta categoría gramatical y posee una cantidad determinada de atributos con información relevante para las siguientes fases de análisis.
En esta etapa, además, se filtran elementos como los espacios en blanco y los comentarios.

\subsubsection{Análisis Sintáctico}

Esta es la fase que comúnmente se denomina \textit{parser}.
El parser utiliza los tokens obtenidos en la etapa previa, para crear una representación intermedia de la estructura gramatical del flujo total de tokens.
Como mencionamos anteriormente, nosotros utilizaremos un \textit{árbol de sintaxis abstracta} como representación.
Las fases posteriores del intérprete emplearán esta estructura gramatical para continuar el análisis del programa fuente.

\subsubsection{Análisis Semántico}

La última etapa del análisis es la de \textit{chequeos estáticos}.
La misma se encarga de verificar si las restricciones semánticas impuestas en la definición del lenguaje son respetadas.
Una parte importante de este análisis es el llamado chequeo de tipos (\textit{typecheck}).
Comúnmente, esta fase toma como entrada la representación intermedia obtenida en la etapa previa, y le agrega las anotaciones de tipos adecuadas, necesarias para continuar el análisis en etapas posteriores.

\subsection{Síntesis}

La parte de síntesis de un compilador es muy diferente a la de un intérprete.
Para el primero, tenemos que construir el programa objetivo utilizando la representación intermedia, junto con toda la información adicional recopilada en las etapas previas.
Habitualmente, esta fase se divide en otras dos partes, la \textit{generación de código intermedio} y la \textit{generación de código objeto}.
En la \textit{generación de código intermedio} se obtiene una representación independiente de la máquina, pero fácilmente traducible a lenguaje ensamblador.
En cambio, la \textit{generación de código objeto} es totalmente dependiente de la arquitectura concreta para la que se esté desarrollando el compilador.
Adicionalmente, durante estas fases comúnmente se aplica algún proceso de optimización sobre el código generado.

Del otro lado, como el objetivo de un intérprete difiere con el de un compilador, sus etapas de síntesis también lo hacen en la misma manera.
Para obtener los resultados del programa, debemos partir del \textit{árbol de sintaxis abstracta} obtenido luego de la fase de \textit{análisis} del intérprete y, junto con los datos de entrada sustentados por el usuario, simular la ejecución del programa en base a las acciones especificadas en el código del mismo.
De esta forma, una vez finalizada la ejecución, se obtienen las salidas del programa.
En la imagen~\ref{Fases} se puede observar la estructura de nuestro intérprete.

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{Fases.png}
\caption{Estructura de un intérprete}
\label{Fases}
\end{figure}
\fi

% Ideas!!
\iffalse

% cosas que faltan
* Manejo de errores y excepciones
* canales de input y output

% concepto
Introducción: Presentar lo que estamos haciendo, es decir, contar que hay un lenguaje definido informal e incompletamente con el que se enseña una materia. Presentar ejemplos de todo lo que se hace con el lenguaje. Como si se lo contaras a alguien que sabe de programación pero no cursó la materia.
Contaríamos también qué cosas NO están bien definidas, qué ambigüedades encontramos, etc

% idea
la idea que tengo es que en la introducción hablamos de las características del lenguaje, y de lo que se enseña en la materia con él
pero no hablamos del lenguaje en particular
o sea, podemos dar algún ejemplo
pero no es que presentamos "el lenguaje tiene estas instrucciones: blablabl"
sino que decimos que es un lenguaje imperativo, que tiene manejo de memoria, etcétera
mencionamos todas las características
pero no damos formalmente nada
en el primer capítulo sí presentaríamos más detalladamente el lenguaje, como un tutorial
(el lenguaje nuestro, ya bien definido)
(pero no formalmente, sino como tutorial)
o sea, luego de leer la introducción, el lector tiene que saber de qué se trata el lenguaje, qué características tiene (o queremos que tenga), que cosas NO tiene
(y no va a tener)
pero no es que leyendo la intro lo vaya a aprender a usar
cuando lea el primer capítulo sí ya puede programar
a partir del capítulo 2 ya sería algo técnico
de cómo lo implementamos

% finalidad
incluida la finalidad con respecto a la materia también

% motivación
o sea, lo que yo dije es medio breve
me parece bueno que primero esté la motivación
¿por qué otro lenguaje?
o sea, no es que estamos definiendo un lenguaje imperativo porque tenemos ganas
sino que hay un motivo inicial
y es didáctico
así que sí, hay que hablar de la materia y de los conceptos que se enseñan con este lenguaje (que son muchísimos)

% estructura
o sea imagino de mínima:
Intro:
* Motivación
* Características del lenguaje
* Organización general de la tesis

% diferencias
pero no se pretende que alguien lea la intro y pueda programar
se pretende que alguien entienda por qué queremos implementar este lenguaje, y qué características tiene

% características
deberíamos hablar de tipado, de polimorfismo, de encapsulamiento
deberíamos hablar de manejo de memoria
de qué conceptos se enseñan en la materia
\fi